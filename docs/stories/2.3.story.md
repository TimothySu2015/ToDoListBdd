# Story 2.3: 編輯任務內容功能

## Status
Draft

## Story
**As a** 生產力使用者，
**I want** 雙擊任務文字進行內聯編輯來修改任務描述，
**so that** 我可以更新或修正任務資訊而不需重新建立任務。

## Acceptance Criteria
1. 雙擊任務文字時進入編輯模式，顯示內聯編輯輸入框
2. 編輯輸入框包含原始任務文字且獲得焦點
3. 按 Enter 鍵保存變更並退出編輯模式
4. 按 Escape 鍵取消變更並退出編輯模式
5. 點擊輸入框外部自動保存變更並退出編輯模式
6. 編輯時驗證任務描述不可為空白或僅包含空格
7. 任務更新後顯示新的任務文字內容
8. 狀態變更即時同步到後端 API 和資料庫
9. 網路錯誤時內容回滾並顯示錯誤訊息
10. 編輯模式中任務項目有明顯的視覺指示（邊框高亮）
11. 支援 Ctrl+Z 撤銷編輯操作
12. 編輯變更時更新任務的 UpdatedAt 時間戳記

## Tasks / Subtasks
- [ ] 擴展後端 CQRS 命令處理 (AC: 8, 12)
  - [ ] 建立 UpdateTaskDescriptionCommand 命令
  - [ ] 實作 UpdateTaskDescriptionCommandHandler
  - [ ] 建立 UpdateTaskDescriptionCommandValidator 驗證器
  - [ ] 確保任務描述不為空白的驗證邏輯
- [ ] 實作 REST API 端點 (AC: 8, 9)
  - [ ] 在 TasksController 新增 PATCH /api/tasks/{id}/description 端點
  - [ ] 實作任務 ID 驗證邏輯
  - [ ] 新增描述更新錯誤處理
  - [ ] 確保資料庫事務完整性
- [ ] 擴展前端任務服務 (AC: 8, 9)
  - [ ] 在 TaskService 新增 updateTaskDescription API 方法
  - [ ] 實作樂觀更新和錯誤回滾機制
  - [ ] 新增載入狀態管理
  - [ ] 實作重試機制
- [ ] 實作內聯編輯元件功能 (AC: 1, 2, 10)
  - [ ] 在 TaskListComponent 新增雙擊事件處理
  - [ ] 建立內聯編輯狀態管理
  - [ ] 實作編輯模式切換邏輯
  - [ ] 新增編輯中的視覺指示樣式
- [ ] 實作編輯操作控制 (AC: 3, 4, 5, 11)
  - [ ] 實作 Enter 鍵保存功能
  - [ ] 實作 Escape 鍵取消功能
  - [ ] 實作點擊外部自動保存
  - [ ] 新增 Ctrl+Z 撤銷功能
- [ ] 實作輸入驗證和錯誤處理 (AC: 6, 9)
  - [ ] 新增前端輸入驗證邏輯
  - [ ] 實作空白內容驗證提示
  - [ ] 新增網路錯誤回滾機制
  - [ ] 實作錯誤訊息顯示
- [ ] 實作視覺回饋和動畫 (AC: 7, 10)
  - [ ] 建立編輯模式的CSS樣式
  - [ ] 實作編輯框獲得焦點的視覺效果
  - [ ] 新增保存成功的視覺回饋
  - [ ] 優化編輯模式的用戶體驗
- [ ] 整合前後端功能測試 (AC: 1-12)
  - [ ] 測試完整的編輯流程
  - [ ] 驗證輸入驗證和錯誤處理
  - [ ] 測試鍵盤快捷鍵功能
  - [ ] 確認資料持久化和同步

## Dev Notes

### 依賴前一個故事
此故事依賴 **Story 2.1** 和 **Story 2.2** 的完成：
- 需要 TodoTask 資料模型和資料庫結構
- 需要基本的 CQRS 架構和 MediatR 配置
- 需要 TasksController 和基本 API 結構
- 需要前端 TaskService 和基本元件結構
- 需要任務狀態管理功能

### BDD 測試場景框架
此故事基於以下 BDD 測試場景實作：

**主要測試場景：**
```gherkin
Feature: 內聯編輯任務內容
  As a 生產力使用者
  I want to 編輯任務描述
  So that 我可以更新任務資訊

Scenario: 啟動內聯編輯模式
  Given 我有一個任務 "完成專案報告"
  When 我雙擊任務文字
  Then 應該顯示內聯編輯輸入框
  And 輸入框應該包含 "完成專案報告"
  And 輸入框應該獲得焦點
  And 任務項目應該顯示編輯模式高亮

Scenario: 使用 Enter 鍵保存編輯
  Given 我正在編輯任務 "完成專案報告"
  When 我修改文字為 "完成季度專案報告"
  And 我按下 Enter 鍵
  Then 編輯模式應該結束
  And 任務文字應該更新為 "完成季度專案報告"
  And 應該顯示保存成功的視覺回饋

Scenario: 使用 Escape 鍵取消編輯
  Given 我正在編輯任務 "完成專案報告"
  When 我修改文字為 "修改後的內容"
  And 我按下 Escape 鍵
  Then 編輯模式應該結束
  And 任務文字應該保持 "完成專案報告"
  And 修改應該被取消

Scenario: 點擊外部自動保存
  Given 我正在編輯任務 "完成專案報告"
  When 我修改文字為 "更新的報告內容"
  And 我點擊任務項目外部區域
  Then 編輯模式應該結束
  And 任務文字應該更新為 "更新的報告內容"

Scenario: 驗證空白內容
  Given 我正在編輯任務 "完成專案報告"
  When 我清空所有文字
  And 我按下 Enter 鍵
  Then 應該顯示錯誤訊息 "任務描述不可為空"
  And 編輯模式應該保持
  And 輸入框應該重新獲得焦點

Scenario: 網路錯誤時內容回滾
  Given 我正在編輯任務 "完成專案報告"
  When API 服務無法回應
  And 我修改文字為 "新的內容"
  And 我按下 Enter 鍵
  Then 應該顯示錯誤訊息 "更新失敗，請重試"
  And 任務文字應該回滾到 "完成專案報告"
  And 編輯模式應該結束

Scenario: 撤銷編輯操作
  Given 我正在編輯任務 "完成專案報告"
  When 我修改文字為 "修改後的內容"
  And 我按下 Ctrl+Z
  Then 輸入框內容應該恢復到 "完成專案報告"
  And 編輯模式應該保持
```

### 擴展現有資料模型 [Source: Story 2.1 - TodoTask 實體]
**現有的 TodoTask 實體已包含必要欄位：**
```csharp
public class TodoTask
{
    public int Id { get; set; }
    public string Description { get; set; } = string.Empty;  // 編輯功能將修改此欄位
    public bool IsCompleted { get; set; } = false;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;  // 需要在編輯時更新
}
```

### CQRS 擴展實作 [Source: architecture.md#CQRS 實作指導原則]
**UpdateTaskDescriptionCommand 結構：**
```csharp
public class UpdateTaskDescriptionCommand : IRequest<TaskDto>
{
    public int TaskId { get; set; }
    public string NewDescription { get; set; } = string.Empty;
}

public class UpdateTaskDescriptionCommandValidator : AbstractValidator<UpdateTaskDescriptionCommand>
{
    public UpdateTaskDescriptionCommandValidator()
    {
        RuleFor(x => x.TaskId)
            .GreaterThan(0).WithMessage("任務 ID 必須大於 0");
            
        RuleFor(x => x.NewDescription)
            .NotEmpty().WithMessage("任務描述不可為空")
            .NotNull().WithMessage("任務描述不可為空")
            .Must(desc => !string.IsNullOrWhiteSpace(desc))
            .WithMessage("任務描述不可僅包含空格");
    }
}

public class UpdateTaskDescriptionCommandHandler : IRequestHandler<UpdateTaskDescriptionCommand, TaskDto>
{
    private readonly ITaskRepository _repository;
    
    public async Task<TaskDto> Handle(UpdateTaskDescriptionCommand request, CancellationToken cancellationToken)
    {
        var task = await _repository.GetByIdAsync(request.TaskId);
        if (task == null)
            throw new NotFoundException($"找不到 ID 為 {request.TaskId} 的任務");
            
        task.Description = request.NewDescription.Trim();
        task.UpdatedAt = DateTime.UtcNow;
        
        await _repository.UpdateAsync(task);
        return task.ToDto();
    }
}
```

### API 端點擴展 [Source: architecture.md#API 控制器指導原則]
**新增 API 端點：**
- 端點：`PATCH /api/tasks/{id}/description`
- 請求體：`{ "newDescription": "更新的任務描述" }`
- 成功回應：`200 OK` + 更新後的 TaskDto
- 錯誤回應：`404 Not Found`（任務不存在）、`400 Bad Request`（驗證錯誤）

```csharp
[HttpPatch("{id}/description")]
public async Task<ActionResult<TaskDto>> UpdateTaskDescription(int id, UpdateTaskDescriptionRequest request)
{
    var command = new UpdateTaskDescriptionCommand
    {
        TaskId = id,
        NewDescription = request.NewDescription
    };
    
    try
    {
        var result = await _mediator.Send(command);
        return Ok(result);
    }
    catch (NotFoundException)
    {
        return NotFound($"找不到 ID 為 {id} 的任務");
    }
    catch (ValidationException ex)
    {
        return BadRequest(ex.Message);
    }
}

public class UpdateTaskDescriptionRequest
{
    public string NewDescription { get; set; } = string.Empty;
}
```

### 前端服務擴展 [Source: architecture.md#狀態管理策略]
**TaskService 新增方法：**
```typescript
export interface TaskService {
  // 現有方法從 Story 2.1 和 2.2
  createTask(description: string): Observable<Task>;
  updateTaskStatus(taskId: number, isCompleted: boolean): Observable<Task>;
  
  // 新增方法
  updateTaskDescription(taskId: number, newDescription: string): Observable<Task>;
}

// 實作樂觀更新和錯誤回滾
updateTaskDescription(taskId: number, newDescription: string): Observable<Task> {
  // 驗證輸入
  if (!newDescription || !newDescription.trim()) {
    return throwError(() => new Error('任務描述不可為空'));
  }

  return this.http.patch<Task>(`/api/tasks/${taskId}/description`, { 
    newDescription: newDescription.trim() 
  }).pipe(
    tap(updatedTask => this.updateTaskInState(updatedTask)),
    catchError(error => {
      // 錯誤處理邏輯
      return throwError(() => error);
    })
  );
}
```

### 前端元件擴展 [Source: architecture.md#前端架構]
**TaskListComponent 新增編輯功能：**
```typescript
export class TaskListComponent {
  editingTaskId: number | null = null;
  editingValue: string = '';
  originalValue: string = '';

  // 啟動編輯模式
  startEditing(task: Task): void {
    this.editingTaskId = task.id;
    this.editingValue = task.description;
    this.originalValue = task.description;
    
    // 下一個 tick 後設置焦點
    setTimeout(() => {
      const input = document.querySelector(`[data-task-id="${task.id}"] input`) as HTMLInputElement;
      if (input) {
        input.focus();
        input.select();
      }
    });
  }

  // 保存編輯
  saveEdit(taskId: number): void {
    if (!this.editingValue.trim()) {
      this.showError('任務描述不可為空');
      return;
    }

    this.taskService.updateTaskDescription(taskId, this.editingValue).subscribe({
      next: (updatedTask) => {
        this.exitEditMode();
        this.showSuccess('任務更新成功');
      },
      error: (error) => {
        this.showError('更新失敗，請重試');
        this.editingValue = this.originalValue;
      }
    });
  }

  // 取消編輯
  cancelEdit(): void {
    this.editingValue = this.originalValue;
    this.exitEditMode();
  }

  // 退出編輯模式
  exitEditMode(): void {
    this.editingTaskId = null;
    this.editingValue = '';
    this.originalValue = '';
  }

  // 鍵盤事件處理
  onEditKeyDown(event: KeyboardEvent, taskId: number): void {
    switch (event.key) {
      case 'Enter':
        event.preventDefault();
        this.saveEdit(taskId);
        break;
      case 'Escape':
        event.preventDefault();
        this.cancelEdit();
        break;
    }
  }

  // 撤銷功能（Ctrl+Z）
  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.ctrlKey && event.key === 'z' && this.editingTaskId) {
      event.preventDefault();
      this.editingValue = this.originalValue;
    }
  }

  // 點擊外部處理
  @HostListener('document:click', ['$event'])
  onDocumentClick(event: MouseEvent): void {
    if (this.editingTaskId) {
      const target = event.target as HTMLElement;
      const editingInput = document.querySelector(`[data-task-id="${this.editingTaskId}"] input`);
      
      if (editingInput && !editingInput.contains(target)) {
        this.saveEdit(this.editingTaskId);
      }
    }
  }
}
```

### HTML 模板結構
**TaskListComponent 模板：**
```html
<div class="task-item" 
     [class.editing]="editingTaskId === task.id" 
     *ngFor="let task of tasks" 
     [attr.data-task-id]="task.id">
  
  <!-- 正常顯示模式 -->
  <span *ngIf="editingTaskId !== task.id"
        class="task-text"
        [class.completed]="task.isCompleted"
        (dblclick)="startEditing(task)"
        [attr.data-testid]="'task-text'">
    {{ task.description }}
  </span>
  
  <!-- 編輯模式 -->
  <input *ngIf="editingTaskId === task.id"
         type="text"
         class="task-edit-input"
         [(ngModel)]="editingValue"
         (keydown)="onEditKeyDown($event, task.id)"
         (blur)="saveEdit(task.id)"
         [attr.data-testid]="'task-edit-input'"
         maxlength="200">
</div>
```

### CSS 樣式設計
**編輯模式視覺效果：**
```scss
.task-item {
  padding: 12px;
  border: 1px solid transparent;
  border-radius: 4px;
  transition: all 0.2s ease;
  
  &.editing {
    border-color: #3b82f6;
    background-color: #eff6ff;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }
  
  .task-text {
    display: block;
    cursor: text;
    padding: 4px;
    border-radius: 2px;
    transition: background-color 0.2s ease;
    
    &:hover {
      background-color: #f9fafb;
    }
    
    &.completed {
      text-decoration: line-through;
      opacity: 0.7;
      color: #6b7280;
    }
  }
  
  .task-edit-input {
    width: 100%;
    border: 1px solid #d1d5db;
    border-radius: 4px;
    padding: 8px;
    font-size: inherit;
    font-family: inherit;
    
    &:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
    }
  }
}

.success-message {
  color: #10b981;
  font-size: 14px;
  margin-top: 4px;
}

.error-message {
  color: #ef4444;
  font-size: 14px;
  margin-top: 4px;
}
```

### 測試要求 [Source: bdd-testing-strategy.md]
**前端 BDD 測試：**
- 測試檔案：`tests/frontend-bdd/features/task-inline-edit.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/task-inline-edit.steps.ts`
- 重點測試：雙擊編輯、鍵盤操作、驗證邏輯、錯誤處理

**後端 BDD 測試：**
- 測試檔案：`tests/backend-bdd/Features/TaskDescriptionUpdate.feature`
- 步驟定義：`tests/backend-bdd/StepDefinitions/TaskDescriptionUpdateSteps.cs`
- 重點測試：PATCH API、資料驗證、錯誤處理、時間戳更新

**E2E BDD 測試：**
- 完整編輯流程測試
- 多任務編輯場景
- 錯誤恢復驗證

### 效能考量
**前端效能：**
- 編輯狀態使用本地組件狀態避免頻繁狀態更新
- 輸入防抖動避免過多 API 調用
- 使用 OnPush 變更檢測策略

**後端效能：**
- 描述字段長度限制（200字符）
- 資料庫索引優化 TaskId 查詢
- 輸入清理和驗證

### 無障礙性支援
**鍵盤導航：**
- Tab 鍵可導航到任務項目
- 雙擊或 F2 鍵啟動編輯模式
- Enter 保存，Escape 取消

**螢幕閱讀器：**
- 編輯模式狀態通知
- 適當的 ARIA 標籤
- 錯誤訊息的無障礙通知

### Testing
**測試標準：** [Source: bdd-testing-strategy.md]
- 前端測試：Jasmine + Karma (Angular 預設)
- 後端測試：xUnit (.NET 標準測試框架)
- BDD 測試：SpecFlow (後端) + Cucumber (前端)
- E2E 測試：SpecFlow + Selenium WebDriver

**此故事的特定測試需求：**
- 內聯編輯功能的單元測試
- UpdateTaskDescriptionCommand 的整合測試
- 前端編輯互動測試
- 鍵盤快捷鍵測試
- 輸入驗證測試
- 錯誤處理和回滾機制測試
- 樂觀更新的正確性測試

**⚠️ DEV 需要補完的關鍵技術細節：**

1. **API 響應格式標準化** - 需要確認所有 API 端點的響應格式一致性
2. **錯誤處理統一化** - 需要建立統一的前端錯誤處理機制
3. **載入狀態管理** - 需要實作編輯過程中的載入狀態指示器
4. **資料庫遷移腳本** - 如果需要修改 TaskDescription 欄位約束
5. **E2E 測試環境設置** - 需要配置完整的測試環境以支援編輯功能測試
6. **效能監控** - 需要加入編輯操作的效能追蹤指標

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-21 | 1.0 | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used
_待開發代理填寫_

### Debug Log References
_待開發代理填寫_

### Completion Notes List
_待開發代理填寫_

### File List
_待開發代理填寫_

## QA Results

### Review Date: 2025-08-21

### Reviewed By: Quinn (Test Architect)

### 審查前提條件檢查

**⚠️ 阻塞條件識別:**
- 故事狀態為 "Draft"，不符合審查前提條件（需要 "Review" 狀態）
- 缺少完整的檔案實作列表（File List 為空）
- 尚無相關的程式碼實作檔案
- 無相關測試檔案存在

### 風險評估分析

**自動升級到深度審查條件:**
- ✓ 故事包含 >5 個驗收標準（12個）- 觸發深度審查
- ✓ 沒有相關實作程式碼和測試 - 觸發深度審查

**風險評估矩陣:**

| 風險類別 | 風險等級 | 說明 |
|---------|---------|------|
| 技術實作複雜度 | HIGH (8/10) | 內聯編輯功能涉及前後端、UI/UX、驗證、錯誤處理等多個技術面向 |
| 用戶體驗風險 | MEDIUM (6/10) | 鍵盤操作、焦點管理、視覺回饋等需要精密的用戶體驗設計 |
| 資料完整性風險 | MEDIUM (5/10) | 樂觀更新和錯誤回滾機制需要確保資料一致性 |
| 測試覆蓋風險 | HIGH (9/10) | 複雜的前端互動行為需要全面的測試覆蓋 |

### 需求追蹤性分析

**驗收標準覆蓋度評估:**
- AC 1-12: 無對應測試實作 ❌
- 缺少以下關鍵測試場景映射:
  - 雙擊編輯功能測試
  - 鍵盤快捷鍵互動測試
  - 輸入驗證和錯誤處理測試
  - 網路錯誤回滾測試

### 程式碼品質評估

**架構設計評估:**
- ✓ CQRS 架構設計符合專案標準
- ✓ 前端使用 Angular Signals 狀態管理
- ✓ RESTful API 設計符合專案慣例

**實作缺口識別:**
1. **後端實作缺少:**
   - UpdateTaskDescriptionCommand 命令
   - UpdateTaskDescriptionCommandHandler 處理器
   - UpdateTaskDescriptionCommandValidator 驗證器
   - TasksController 的 PATCH /description 端點

2. **前端實作缺少:**
   - TaskService 的 updateTaskDescription 方法
   - TaskListComponent 的編輯功能
   - 編輯模式的 CSS 樣式
   - 鍵盤事件處理邏輯

### 測試架構評估

**測試層級適當性:**
- E2E 測試: 需要完整編輯流程測試 📝 計劃中
- 前端 BDD 測試: 需要 UI 互動行為測試 📝 計劃中  
- 後端 BDD 測試: 需要 API 行為驗證測試 📝 計劃中
- 單元測試: 需要元件和服務層測試 📝 計劃中

**測試設計品質:**
- BDD 場景覆蓋度：優秀 ✓
- Gherkin 語法品質：優秀 ✓
- 測試資料管理策略：需要規劃 📝

### 非功能性需求驗證

**安全性 (Security): 需要關注**
- 輸入驗證：前後端雙重驗證機制已規劃 ✓
- 資料清理：trim() 和長度限制已考慮 ✓  
- SQL 注入防護：Entity Framework 提供保護 ✓

**效能 (Performance): 良好**
- 樂觀更新策略減少使用者感知延遲 ✓
- 本地狀態管理避免不必要的 API 呼叫 ✓
- 需要添加防抖動機制避免頻繁 API 請求 📝

**可靠性 (Reliability): 良好**  
- 錯誤回滾機制已規劃 ✓
- 網路錯誤處理策略完整 ✓
- 輸入驗證多層防護 ✓

**可維護性 (Maintainability): 優秀**
- 關注點分離清楚 ✓
- CQRS 架構提供良好可擴展性 ✓
- 程式碼結構清晰易懂 ✓

### 可測試性評估

**控制能力 (Controllability):** 良好
- API 端點可控制輸入參數 ✓
- 前端元件支援屬性注入測試 ✓

**觀察能力 (Observability):** 優秀  
- API 回應可觀察 ✓
- 前端狀態變更可觀察 ✓
- 錯誤狀態可觀察 ✓

**除錯能力 (Debuggability):** 良好
- 清楚的錯誤訊息設計 ✓
- 前端狀態可追蹤 ✓

### 技術債務識別

**當前技術債務:**
1. 缺少完整實作（預期中）
2. TasksController 缺少 GetTask 實作（來自前期故事）
3. 前端錯誤處理機制需要標準化

**潛在技術債務預防:**
1. 需要制定一致的 API 響應格式標準
2. 需要統一的前端錯誤處理策略
3. 需要編輯操作的效能監控機制

### 標準合規性檢查

- **編碼標準**: ✓ 符合（基於現有程式碼結構）
- **專案結構**: ✓ 符合統一專案結構
- **測試策略**: ✓ 符合 BDD 測試策略
- **架構指導原則**: ✓ 符合 CQRS 和分層架構

### 改進建議清單

**立即處理項目（阻塞發布）:**
- [ ] 完成後端 UpdateTaskDescription CQRS 實作
- [ ] 完成前端編輯功能實作  
- [ ] 建立對應的 BDD 測試場景
- [ ] 實作輸入驗證和錯誤處理機制

**未來改進項目（非阻塞）:**
- [ ] 加入編輯操作的效能監控
- [ ] 考慮加入編輯歷史記錄功能
- [ ] 優化大量任務時的編輯效能
- [ ] 加入編輯操作的無障礙性支援

### 門檻狀態

Gate: FAIL → docs/qa/gates/2.3-編輯任務內容功能.yml

**失敗原因：**
1. 故事狀態不符合審查條件（Draft 而非 Review）
2. 缺少必要的程式碼實作
3. 無對應測試檔案
4. File List 未更新

### 建議狀態

✗ 變更必需 - 需要完成實作並更新故事狀態至 Review 後重新審查

**開發者後續行動：**
1. 完成所有 Tasks/Subtasks 中的實作項目
2. 建立並執行相關測試
3. 更新 File List 包含所有異動檔案  
4. 將故事狀態更新為 Review
5. 重新要求 QA 審查