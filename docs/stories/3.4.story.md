# Story 3.4: 鍵盤快捷鍵支援功能

## Status

Draft

## Story

**As a** 生產力使用者，
**I want** 使用鍵盤快捷鍵快速執行常用操作，
**so that** 我可以提高操作效率並減少對滑鼠的依賴。

## Acceptance Criteria

1. 支援 Ctrl+N（新增任務）：快速聚焦到任務輸入框
2. 支援 Ctrl+F（搜尋任務）：快速聚焦到搜尋輸入框
3. 支援 Space（切換完成狀態）：在任務項目獲得焦點時切換完成狀態
4. 支援 Enter（編輯任務）：在任務項目獲得焦點時進入編輯模式
5. 支援 Delete（刪除任務）：在任務項目獲得焦點時刪除任務（需確認）
6. 支援 Escape（取消操作）：取消當前編輯或關閉對話框
7. 支援 Tab（焦點導航）：在所有可互動元素間循環導航
8. 支援 1/2/3 數字鍵：快速切換檢視（1=待辦，2=已完成，3=全部）
9. 支援 Ctrl+A（全選模式）：進入批量操作模式（未來擴展）
10. 支援 Ctrl+D（清除已完成）：快速清除已完成任務
11. 顯示快捷鍵提示：Ctrl+? 或 F1 顯示快捷鍵說明
12. 快捷鍵在所有瀏覽器中一致運作，不與瀏覽器默認快捷鍵衝突

## Tasks / Subtasks

**⚡ 業務功能 Story - 必須遵循 BDD 驅動流程**

### 階段 1: BDD 場景建立 (Story 第一步)

- [ ] 撰寫完整 BDD 場景涵蓋所有快捷鍵功能情境 (AC: 1-12)
- [ ] 場景驗證：確保涵蓋主要使用情境、邊界條件和錯誤情況
- [ ] 場景品質檢查：具體、可測試、與功能需求一致

### 階段 2: 技術需求推導 (基於 BDD 場景)

- [ ] 從 BDD 場景推導後端技術需求 (AC: 無特殊後端需求)
  - [ ] 確認現有 API 足以支援快捷鍵操作
  - [ ] 無需新增後端 API，重用現有 CQRS 結構
- [ ] 從 BDD 場景推導前端技術需求 (AC: 1-12)
  - [ ] 分析場景中的 UI 元件：快捷鍵監聽器、焦點管理、說明對話框
  - [ ] 設計 KeyboardShortcutService 元件基於場景互動
  - [ ] 設計全域快捷鍵監聽和焦點管理系統
  - [ ] 設計快捷鍵說明和無障礙功能

### 階段 3: 測試先行 (TDD + BDD)

- [ ] 建立前端 BDD 測試 (Red Phase) (AC: 1-12)
  - [ ] 建立 keyboard-shortcuts.feature 文件
  - [ ] 實作 keyboard-shortcuts.steps.ts 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有快捷鍵場景

### 階段 4: 最小實作 (Green Phase)

- [ ] 實作全域快捷鍵功能 (綠燈最小實作) (AC: 1-12)
  - [ ] 建立 KeyboardShortcutService 服務
  - [ ] 實作全域快捷鍵監聽器
  - [ ] 建立焦點管理和導航系統
  - [ ] 實作快捷鍵說明對話框
  - [ ] 運行前端 BDD 測試確認通過 (Green)
- [ ] 整合現有元件快捷鍵功能 (AC: 所有相關)
  - [ ] 整合任務列表的快捷鍵支援
  - [ ] 整合搜尋和檢視切換的快捷鍵
  - [ ] 整合清除功能的快捷鍵
  - [ ] 運行整合測試確認所有場景通過

### 階段 5: 重構和增強 (Blue Phase)

- [ ] 優化用戶體驗和效能 (AC: 11, 12)
  - [ ] 實作快捷鍵視覺提示和工具提示
  - [ ] 優化快捷鍵回應速度和準確性
  - [ ] 實作自訂快捷鍵功能（可選）
  - [ ] 加強瀏覽器相容性處理
- [ ] 程式碼重構和最佳化
  - [ ] 重構重複程式碼和改善架構
  - [ ] 優化事件監聽器效能
  - [ ] 加強錯誤處理和邊界情況
  - [ ] 確保程式碼符合專案編碼標準

### 階段 6: 完整驗證 (AC: 1-12)

- [ ] E2E BDD 測試執行
  - [ ] 運行完整的快捷鍵功能 E2E 測試
  - [ ] 驗證跨瀏覽器快捷鍵相容性
  - [ ] 測試快捷鍵與其他功能的整合
- [ ] 回歸測試和品質確保
  - [ ] 確認不影響現有 Epic 2 和 Story 3.1-3.3 功能
  - [ ] 運行完整測試套件
  - [ ] 驗證所有驗收標準達成

## Dev Notes

### 依賴前一個故事

此故事建立在 **Epic 2 完整實作** 和 **Story 3.1-3.3 功能** 的基礎上：

- 需要 TodoTask 資料模型和 CRUD 基礎功能 (Story 2.1-2.4)
- 需要前端 TaskService 和 TaskListComponent
- 需要 Angular Signals 狀態管理機制
- 需要檢視切換功能（3.1）的快捷鍵整合
- 需要搜尋功能（3.2）的快捷鍵整合
- 需要清除功能（3.3）的快捷鍵整合

### BDD 測試場景框架

此故事基於以下 BDD 測試場景實作：

**主要測試場景：**

```gherkin
Feature: 鍵盤快捷鍵支援
  As a 生產力使用者
  I want to 使用鍵盤快捷鍵操作應用程式
  So that 我可以提高操作效率

Scenario: 新增任務快捷鍵 (Ctrl+N)
  Given 我在任務頁面
  When 我按下 Ctrl+N
  Then 任務輸入框應該獲得焦點
  And 游標應該在輸入框中

Scenario: 搜尋任務快捷鍵 (Ctrl+F)
  Given 我在任務頁面
  When 我按下 Ctrl+F
  Then 搜尋輸入框應該獲得焦點
  And 游標應該在搜尋框中

Scenario: 任務操作快捷鍵
  Given 我有任務 "測試任務"
  And 任務項目獲得焦點
  When 我按下 Space 鍵
  Then 任務應該切換完成狀態
  
  When 我按下 Enter 鍵
  Then 任務應該進入編輯模式
  
  When 我按下 Delete 鍵
  Then 應該顯示刪除確認對話框

Scenario: 檢視切換快捷鍵 (數字鍵)
  Given 我在任務頁面
  When 我按下數字鍵 "1"
  Then 應該切換到「待辦」檢視
  When 我按下數字鍵 "2"
  Then 應該切換到「已完成」檢視
  When 我按下數字鍵 "3"
  Then 應該切換到「全部」檢視

Scenario: 清除已完成任務快捷鍵 (Ctrl+D)
  Given 我有已完成任務
  When 我按下 Ctrl+D
  Then 應該顯示清除確認對話框

Scenario: 取消操作快捷鍵 (Escape)
  Given 我在編輯任務模式
  When 我按下 Escape 鍵
  Then 應該取消編輯並恢復原始狀態
  
  Given 我有開啟的對話框
  When 我按下 Escape 鍵
  Then 對話框應該關閉

Scenario: Tab 鍵焦點導航
  Given 我在任務頁面
  When 我按下 Tab 鍵
  Then 焦點應該移動到下一個可互動元素
  When 我按下 Shift+Tab
  Then 焦點應該移動到上一個可互動元素

Scenario: 快捷鍵說明 (Ctrl+? 或 F1)
  Given 我在任務頁面
  When 我按下 Ctrl+?
  Then 應該顯示快捷鍵說明對話框
  And 說明應該列出所有可用快捷鍵

Scenario: 快捷鍵衝突處理
  Given 我在文字輸入框中
  When 我按下 Ctrl+A
  Then 應該全選文字內容
  And 不應該觸發應用程式的全選功能

Scenario: 瀏覽器相容性
  Given 我使用不同瀏覽器（Chrome, Firefox, Safari, Edge）
  When 我使用各種快捷鍵
  Then 所有快捷鍵應該一致運作
  And 不應該與瀏覽器默認行為衝突

Scenario: 快捷鍵視覺提示
  Given 我將滑鼠懸停在按鈕上
  Then 應該顯示對應的快捷鍵提示
  
  Given 我開啟快捷鍵說明
  Then 應該看到清楚的快捷鍵圖表
```

### 架構設計考量 [Source: architecture.md]

**前端快捷鍵架構設計：**

```typescript
// 快捷鍵服務
@Injectable({ providedIn: "root" })
export class KeyboardShortcutService {
  private shortcuts = new Map<string, ShortcutHandler>();
  private isListening = signal<boolean>(false);
  private currentFocus = signal<HTMLElement | null>(null);

  constructor(
    private focusManager: FocusManagerService,
    private taskService: TaskService,
    private viewStateService: ViewStateService,
    private clearService: ClearCompletedService
  ) {
    this.initializeShortcuts();
  }

  ngOnInit() {
    this.startListening();
  }

  private initializeShortcuts(): void {
    // 註冊所有快捷鍵
    this.registerShortcut('ctrl+n', this.focusNewTaskInput.bind(this));
    this.registerShortcut('ctrl+f', this.focusSearchInput.bind(this));
    this.registerShortcut('ctrl+d', this.clearCompletedTasks.bind(this));
    this.registerShortcut('ctrl+?', this.showHelp.bind(this));
    this.registerShortcut('f1', this.showHelp.bind(this));
    this.registerShortcut('escape', this.cancelCurrentAction.bind(this));
    this.registerShortcut('space', this.toggleTaskCompletion.bind(this));
    this.registerShortcut('enter', this.editFocusedTask.bind(this));
    this.registerShortcut('delete', this.deleteFocusedTask.bind(this));
    this.registerShortcut('1', this.switchToTodoView.bind(this));
    this.registerShortcut('2', this.switchToCompletedView.bind(this));
    this.registerShortcut('3', this.switchToAllView.bind(this));
  }

  private registerShortcut(combination: string, handler: ShortcutHandler): void {
    this.shortcuts.set(combination, handler);
  }

  private startListening(): void {
    if (this.isListening()) return;

    document.addEventListener('keydown', this.handleKeyDown.bind(this));
    this.isListening.set(true);
  }

  private handleKeyDown(event: KeyboardEvent): void {
    const combination = this.getKeyCombination(event);
    const handler = this.shortcuts.get(combination);

    if (handler && this.shouldExecuteShortcut(event)) {
      event.preventDefault();
      handler(event);
    }
  }

  private getKeyCombination(event: KeyboardEvent): string {
    const parts: string[] = [];
    
    if (event.ctrlKey) parts.push('ctrl');
    if (event.shiftKey) parts.push('shift');
    if (event.altKey) parts.push('alt');
    if (event.metaKey) parts.push('meta');
    
    parts.push(event.key.toLowerCase());
    
    return parts.join('+');
  }

  private shouldExecuteShortcut(event: KeyboardEvent): boolean {
    const target = event.target as HTMLElement;
    const tagName = target.tagName.toLowerCase();
    
    // 在輸入框中時，只執行特定快捷鍵
    if (tagName === 'input' || tagName === 'textarea') {
      const allowedInInput = ['escape', 'ctrl+a', 'ctrl+?', 'f1'];
      return allowedInInput.includes(this.getKeyCombination(event));
    }
    
    return true;
  }

  // 快捷鍵處理器實作
  private focusNewTaskInput(): void {
    this.focusManager.focusElement('[data-testid="task-input"]');
  }

  private focusSearchInput(): void {
    this.focusManager.focusElement('[data-testid="search-input"]');
  }

  private clearCompletedTasks(): void {
    this.clearService.showConfirmDialog();
  }

  private showHelp(): void {
    this.focusManager.showShortcutHelp();
  }

  private cancelCurrentAction(): void {
    this.focusManager.cancelCurrentAction();
  }

  private toggleTaskCompletion(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      const taskId = parseInt(focusedTask.dataset['taskId']);
      this.taskService.toggleTaskCompletion(taskId);
    }
  }

  private editFocusedTask(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      this.focusManager.enterEditMode(focusedTask);
    }
  }

  private deleteFocusedTask(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      const taskId = parseInt(focusedTask.dataset['taskId']);
      this.taskService.showDeleteConfirmation(taskId);
    }
  }

  private switchToTodoView(): void {
    this.viewStateService.setView(TaskViewType.TODO);
  }

  private switchToCompletedView(): void {
    this.viewStateService.setView(TaskViewType.COMPLETED);
  }

  private switchToAllView(): void {
    this.viewStateService.setView(TaskViewType.ALL);
  }
}

// 焦點管理服務
@Injectable({ providedIn: "root" })
export class FocusManagerService {
  private focusedElement = signal<HTMLElement | null>(null);
  private modalStack: HTMLElement[] = [];

  focusElement(selector: string): void {
    const element = document.querySelector(selector) as HTMLElement;
    if (element) {
      element.focus();
      this.focusedElement.set(element);
    }
  }

  enterEditMode(taskElement: HTMLElement): void {
    // 觸發任務編輯模式
    const editEvent = new CustomEvent('enterEdit');
    taskElement.dispatchEvent(editEvent);
  }

  showShortcutHelp(): void {
    // 顯示快捷鍵說明對話框
    const helpDialog = document.querySelector('[data-testid="shortcut-help"]') as HTMLElement;
    if (helpDialog) {
      helpDialog.style.display = 'block';
      this.modalStack.push(helpDialog);
    }
  }

  cancelCurrentAction(): void {
    // 取消當前操作（關閉對話框、退出編輯等）
    if (this.modalStack.length > 0) {
      const topModal = this.modalStack.pop();
      if (topModal) {
        topModal.style.display = 'none';
      }
    }
    
    // 退出編輯模式
    const editingElement = document.querySelector('.editing');
    if (editingElement) {
      const cancelEvent = new CustomEvent('cancelEdit');
      editingElement.dispatchEvent(cancelEvent);
    }
  }

  handleTabNavigation(event: KeyboardEvent): void {
    const focusableElements = this.getFocusableElements();
    const currentIndex = Array.from(focusableElements).indexOf(document.activeElement as HTMLElement);
    
    if (event.shiftKey) {
      // Shift+Tab (向前)
      const previousIndex = currentIndex > 0 ? currentIndex - 1 : focusableElements.length - 1;
      focusableElements[previousIndex]?.focus();
    } else {
      // Tab (向後)
      const nextIndex = currentIndex < focusableElements.length - 1 ? currentIndex + 1 : 0;
      focusableElements[nextIndex]?.focus();
    }
  }

  private getFocusableElements(): HTMLElement[] {
    const selector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    return Array.from(document.querySelectorAll(selector)) as HTMLElement[];
  }
}

// 快捷鍵類型定義
type ShortcutHandler = (event: KeyboardEvent) => void;

interface ShortcutInfo {
  combination: string;
  description: string;
  category: string;
}
```

### 前端元件設計 [Source: architecture.md]

**快捷鍵說明對話框元件：**

```typescript
@Component({
  selector: "app-shortcut-help",
  template: `
    <div class="shortcut-help-overlay" *ngIf="isVisible()" (click)="close()">
      <div class="shortcut-help-content" (click)="$event.stopPropagation()">
        <div class="help-header">
          <h2>鍵盤快捷鍵</h2>
          <button class="close-btn" (click)="close()" [attr.data-testid]="'close-help'">✕</button>
        </div>
        
        <div class="help-body">
          <div class="shortcut-category" *ngFor="let category of shortcutCategories">
            <h3>{{ category.name }}</h3>
            <div class="shortcut-list">
              <div 
                class="shortcut-item" 
                *ngFor="let shortcut of category.shortcuts"
                [attr.data-testid]="'shortcut-' + shortcut.key"
              >
                <div class="shortcut-keys">
                  <span 
                    class="key" 
                    *ngFor="let key of shortcut.keys"
                    [class.modifier]="isModifierKey(key)"
                  >
                    {{ key }}
                  </span>
                </div>
                <div class="shortcut-description">{{ shortcut.description }}</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="help-footer">
          <p class="tip">💡 提示：將滑鼠懸停在按鈕上可查看對應的快捷鍵</p>
        </div>
      </div>
    </div>
  `,
})
export class ShortcutHelpComponent {
  private isVisible = signal<boolean>(false);

  shortcutCategories = [
    {
      name: '基本操作',
      shortcuts: [
        { keys: ['Ctrl', 'N'], description: '新增任務', key: 'new-task' },
        { keys: ['Ctrl', 'F'], description: '搜尋任務', key: 'search' },
        { keys: ['Ctrl', 'D'], description: '清除已完成任務', key: 'clear' },
        { keys: ['Esc'], description: '取消當前操作', key: 'cancel' },
      ]
    },
    {
      name: '任務操作',
      shortcuts: [
        { keys: ['Space'], description: '切換任務完成狀態', key: 'toggle' },
        { keys: ['Enter'], description: '編輯任務', key: 'edit' },
        { keys: ['Del'], description: '刪除任務', key: 'delete' },
      ]
    },
    {
      name: '檢視切換',
      shortcuts: [
        { keys: ['1'], description: '切換到待辦檢視', key: 'view-todo' },
        { keys: ['2'], description: '切換到已完成檢視', key: 'view-completed' },
        { keys: ['3'], description: '切換到全部檢視', key: 'view-all' },
      ]
    },
    {
      name: '導航',
      shortcuts: [
        { keys: ['Tab'], description: '下一個元素', key: 'tab-next' },
        { keys: ['Shift', 'Tab'], description: '上一個元素', key: 'tab-prev' },
        { keys: ['Ctrl', '?'], description: '顯示此說明', key: 'help' },
      ]
    }
  ];

  constructor(private shortcutService: KeyboardShortcutService) {}

  show(): void {
    this.isVisible.set(true);
  }

  close(): void {
    this.isVisible.set(false);
  }

  isModifierKey(key: string): boolean {
    return ['Ctrl', 'Shift', 'Alt', 'Meta'].includes(key);
  }

  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.close();
    }
  }
}
```

**任務項目快捷鍵整合：**

```typescript
@Component({
  selector: "app-task-item",
  template: `
    <div 
      class="task-item"
      [class.focused]="isFocused()"
      [class.editing]="isEditing()"
      [attr.data-task-id]="task.id"
      [attr.data-testid]="'task-item'"
      [attr.tabindex]="0"
      (focus)="onFocus()"
      (blur)="onBlur()"
      (keydown)="onKeyDown($event)"
      (enterEdit)="startEdit()"
      (cancelEdit)="cancelEdit()"
    >
      <!-- 任務內容 -->
      <div class="task-content" *ngIf="!isEditing()">
        <input 
          type="checkbox" 
          [checked]="task.isCompleted"
          (change)="toggleCompletion()"
          [attr.data-testid]="'task-checkbox'"
        />
        <span class="task-text" [class.completed]="task.isCompleted">
          {{ task.description }}
        </span>
        <div class="task-actions">
          <button 
            class="edit-btn" 
            (click)="startEdit()"
            [title]="'編輯 (Enter)'"
            [attr.data-testid]="'edit-button'"
          >
            ✏️
          </button>
          <button 
            class="delete-btn" 
            (click)="deleteTask()"
            [title]="'刪除 (Delete)'"
            [attr.data-testid]="'delete-button'"
          >
            🗑️
          </button>
        </div>
      </div>

      <!-- 編輯模式 -->
      <div class="task-edit" *ngIf="isEditing()">
        <input 
          type="text" 
          [(ngModel)]="editText"
          (keydown)="onEditKeyDown($event)"
          (blur)="saveEdit()"
          [attr.data-testid]="'edit-input'"
          #editInput
        />
      </div>
    </div>
  `,
})
export class TaskItemComponent {
  @Input() task!: Task;
  @Output() taskUpdate = new EventEmitter<Task>();
  @Output() taskDelete = new EventEmitter<number>();

  private isFocused = signal<boolean>(false);
  private isEditing = signal<boolean>(false);
  private editText = signal<string>('');

  onFocus(): void {
    this.isFocused.set(true);
  }

  onBlur(): void {
    this.isFocused.set(false);
  }

  onKeyDown(event: KeyboardEvent): void {
    if (!this.isFocused()) return;

    switch (event.key) {
      case ' ':
        event.preventDefault();
        this.toggleCompletion();
        break;
      case 'Enter':
        event.preventDefault();
        this.startEdit();
        break;
      case 'Delete':
        event.preventDefault();
        this.deleteTask();
        break;
    }
  }

  startEdit(): void {
    this.editText.set(this.task.description);
    this.isEditing.set(true);
    
    // 下一個 tick 聚焦輸入框
    setTimeout(() => {
      const input = document.querySelector('[data-testid="edit-input"]') as HTMLInputElement;
      input?.focus();
    });
  }

  cancelEdit(): void {
    this.isEditing.set(false);
    this.editText.set('');
  }

  saveEdit(): void {
    if (this.editText().trim() && this.editText() !== this.task.description) {
      const updatedTask = { ...this.task, description: this.editText().trim() };
      this.taskUpdate.emit(updatedTask);
    }
    this.isEditing.set(false);
  }

  onEditKeyDown(event: KeyboardEvent): void {
    switch (event.key) {
      case 'Enter':
        event.preventDefault();
        this.saveEdit();
        break;
      case 'Escape':
        event.preventDefault();
        this.cancelEdit();
        break;
    }
  }

  toggleCompletion(): void {
    const updatedTask = { ...this.task, isCompleted: !this.task.isCompleted };
    this.taskUpdate.emit(updatedTask);
  }

  deleteTask(): void {
    this.taskDelete.emit(this.task.id);
  }
}
```

### CSS 設計規範

**快捷鍵相關樣式：**

```scss
// 快捷鍵說明對話框
.shortcut-help-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;

  .shortcut-help-content {
    background: white;
    border-radius: 12px;
    padding: 0;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow: auto;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);

    .help-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 24px 0 24px;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 24px;

      h2 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
        color: #111827;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #6b7280;
        padding: 8px;
        border-radius: 4px;

        &:hover {
          background: #f3f4f6;
          color: #374151;
        }
      }
    }

    .help-body {
      padding: 0 24px;

      .shortcut-category {
        margin-bottom: 32px;

        h3 {
          font-size: 16px;
          font-weight: 600;
          color: #374151;
          margin: 0 0 16px 0;
          padding-bottom: 8px;
          border-bottom: 1px solid #e5e7eb;
        }

        .shortcut-list {
          display: grid;
          gap: 12px;

          .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;

            .shortcut-keys {
              display: flex;
              gap: 4px;

              .key {
                display: inline-block;
                padding: 4px 8px;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
                font-weight: 600;
                color: #374151;
                min-width: 20px;
                text-align: center;

                &.modifier {
                  background: #e5e7eb;
                  color: #111827;
                }
              }
            }

            .shortcut-description {
              color: #6b7280;
              font-size: 14px;
            }
          }
        }
      }
    }

    .help-footer {
      padding: 16px 24px 24px 24px;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;

      .tip {
        margin: 0;
        font-size: 14px;
        color: #6b7280;
        text-align: center;
      }
    }
  }
}

// 任務項目焦點樣式
.task-item {
  outline: none;
  transition: all 0.2s ease;

  &.focused {
    background: #eff6ff;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }

  &:focus-visible {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }
}

// 快捷鍵提示工具提示
.shortcut-tooltip {
  position: absolute;
  background: #374151;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;

  &::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: #374151;
  }
}

// 視覺輔助指示器
.keyboard-mode {
  .focusable {
    position: relative;

    &::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 1px dashed #9ca3af;
      border-radius: 4px;
      opacity: 0.5;
      pointer-events: none;
    }

    &:focus::after {
      border-color: #3b82f6;
      border-style: solid;
      opacity: 1;
    }
  }
}
```

### 測試要求 [Source: bdd-testing-strategy.md]

**前端 BDD 測試：**

- 測試檔案：`tests/frontend-bdd/features/keyboard-shortcuts.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/keyboard-shortcuts.steps.ts`
- 重點測試：所有快捷鍵組合、焦點管理、瀏覽器相容性

**E2E BDD 測試：**

- 完整快捷鍵流程測試
- 跨瀏覽器快捷鍵相容性測試
- 與其他功能的整合測試

### 效能考量

**前端效能：**

- 快捷鍵事件監聽器效能最佳化
- 焦點管理的記憶體使用
- 大量快捷鍵註冊的效能影響

**無障礙性：**

- 螢幕閱讀器相容性
- 高對比度模式支援
- 鍵盤導航的邏輯順序

### Testing

**測試標準：** [Source: bdd-testing-strategy.md]

- 前端測試：Jasmine + Karma (Angular 預設)
- BDD 測試：Cucumber (前端)
- E2E 測試：Selenium WebDriver
- 無障礙測試：axe-core

**此故事的特定測試需求：**

- 所有快捷鍵組合功能測試
- 焦點管理和導航測試
- 快捷鍵衝突和優先級測試
- 瀏覽器相容性測試
- 無障礙功能相容性測試
- 快捷鍵說明對話框測試

## Change Log

| Date       | Version | Description                                   | Author       |
| ---------- | ------- | --------------------------------------------- | ------------ |
| 2025-08-21 | 1.0     | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_待 QA 代理填寫_