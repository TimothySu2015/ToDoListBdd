# Story 3.4: éµç›¤å¿«æ·éµæ”¯æ´åŠŸèƒ½

## Status

Draft

## Story

**As a** ç”Ÿç”¢åŠ›ä½¿ç”¨è€…ï¼Œ
**I want** ä½¿ç”¨éµç›¤å¿«æ·éµå¿«é€ŸåŸ·è¡Œå¸¸ç”¨æ“ä½œï¼Œ
**so that** æˆ‘å¯ä»¥æé«˜æ“ä½œæ•ˆç‡ä¸¦æ¸›å°‘å°æ»‘é¼ çš„ä¾è³´ã€‚

## Acceptance Criteria

1. æ”¯æ´ Ctrl+Nï¼ˆæ–°å¢ä»»å‹™ï¼‰ï¼šå¿«é€Ÿèšç„¦åˆ°ä»»å‹™è¼¸å…¥æ¡†
2. æ”¯æ´ Ctrl+Fï¼ˆæœå°‹ä»»å‹™ï¼‰ï¼šå¿«é€Ÿèšç„¦åˆ°æœå°‹è¼¸å…¥æ¡†
3. æ”¯æ´ Spaceï¼ˆåˆ‡æ›å®Œæˆç‹€æ…‹ï¼‰ï¼šåœ¨ä»»å‹™é …ç›®ç²å¾—ç„¦é»æ™‚åˆ‡æ›å®Œæˆç‹€æ…‹
4. æ”¯æ´ Enterï¼ˆç·¨è¼¯ä»»å‹™ï¼‰ï¼šåœ¨ä»»å‹™é …ç›®ç²å¾—ç„¦é»æ™‚é€²å…¥ç·¨è¼¯æ¨¡å¼
5. æ”¯æ´ Deleteï¼ˆåˆªé™¤ä»»å‹™ï¼‰ï¼šåœ¨ä»»å‹™é …ç›®ç²å¾—ç„¦é»æ™‚åˆªé™¤ä»»å‹™ï¼ˆéœ€ç¢ºèªï¼‰
6. æ”¯æ´ Escapeï¼ˆå–æ¶ˆæ“ä½œï¼‰ï¼šå–æ¶ˆç•¶å‰ç·¨è¼¯æˆ–é—œé–‰å°è©±æ¡†
7. æ”¯æ´ Tabï¼ˆç„¦é»å°èˆªï¼‰ï¼šåœ¨æ‰€æœ‰å¯äº’å‹•å…ƒç´ é–“å¾ªç’°å°èˆª
8. æ”¯æ´ 1/2/3 æ•¸å­—éµï¼šå¿«é€Ÿåˆ‡æ›æª¢è¦–ï¼ˆ1=å¾…è¾¦ï¼Œ2=å·²å®Œæˆï¼Œ3=å…¨éƒ¨ï¼‰
9. æ”¯æ´ Ctrl+Aï¼ˆå…¨é¸æ¨¡å¼ï¼‰ï¼šé€²å…¥æ‰¹é‡æ“ä½œæ¨¡å¼ï¼ˆæœªä¾†æ“´å±•ï¼‰
10. æ”¯æ´ Ctrl+Dï¼ˆæ¸…é™¤å·²å®Œæˆï¼‰ï¼šå¿«é€Ÿæ¸…é™¤å·²å®Œæˆä»»å‹™
11. é¡¯ç¤ºå¿«æ·éµæç¤ºï¼šCtrl+? æˆ– F1 é¡¯ç¤ºå¿«æ·éµèªªæ˜
12. å¿«æ·éµåœ¨æ‰€æœ‰ç€è¦½å™¨ä¸­ä¸€è‡´é‹ä½œï¼Œä¸èˆ‡ç€è¦½å™¨é»˜èªå¿«æ·éµè¡çª

## Tasks / Subtasks

**âš¡ æ¥­å‹™åŠŸèƒ½ Story - å¿…é ˆéµå¾ª BDD é©…å‹•æµç¨‹**

### éšæ®µ 1: BDD å ´æ™¯å»ºç«‹ (Story ç¬¬ä¸€æ­¥)

- [ ] æ’°å¯«å®Œæ•´ BDD å ´æ™¯æ¶µè“‹æ‰€æœ‰å¿«æ·éµåŠŸèƒ½æƒ…å¢ƒ (AC: 1-12)
- [ ] å ´æ™¯é©—è­‰ï¼šç¢ºä¿æ¶µè“‹ä¸»è¦ä½¿ç”¨æƒ…å¢ƒã€é‚Šç•Œæ¢ä»¶å’ŒéŒ¯èª¤æƒ…æ³
- [ ] å ´æ™¯å“è³ªæª¢æŸ¥ï¼šå…·é«”ã€å¯æ¸¬è©¦ã€èˆ‡åŠŸèƒ½éœ€æ±‚ä¸€è‡´

### éšæ®µ 2: æŠ€è¡“éœ€æ±‚æ¨å° (åŸºæ–¼ BDD å ´æ™¯)

- [ ] å¾ BDD å ´æ™¯æ¨å°å¾Œç«¯æŠ€è¡“éœ€æ±‚ (AC: ç„¡ç‰¹æ®Šå¾Œç«¯éœ€æ±‚)
  - [ ] ç¢ºèªç¾æœ‰ API è¶³ä»¥æ”¯æ´å¿«æ·éµæ“ä½œ
  - [ ] ç„¡éœ€æ–°å¢å¾Œç«¯ APIï¼Œé‡ç”¨ç¾æœ‰ CQRS çµæ§‹
- [ ] å¾ BDD å ´æ™¯æ¨å°å‰ç«¯æŠ€è¡“éœ€æ±‚ (AC: 1-12)
  - [ ] åˆ†æå ´æ™¯ä¸­çš„ UI å…ƒä»¶ï¼šå¿«æ·éµç›£è½å™¨ã€ç„¦é»ç®¡ç†ã€èªªæ˜å°è©±æ¡†
  - [ ] è¨­è¨ˆ KeyboardShortcutService å…ƒä»¶åŸºæ–¼å ´æ™¯äº’å‹•
  - [ ] è¨­è¨ˆå…¨åŸŸå¿«æ·éµç›£è½å’Œç„¦é»ç®¡ç†ç³»çµ±
  - [ ] è¨­è¨ˆå¿«æ·éµèªªæ˜å’Œç„¡éšœç¤™åŠŸèƒ½

### éšæ®µ 3: æ¸¬è©¦å…ˆè¡Œ (TDD + BDD)

- [ ] å»ºç«‹å‰ç«¯ BDD æ¸¬è©¦ (Red Phase) (AC: 1-12)
  - [ ] å»ºç«‹ keyboard-shortcuts.feature æ–‡ä»¶
  - [ ] å¯¦ä½œ keyboard-shortcuts.steps.ts æ­¥é©Ÿå®šç¾©
  - [ ] é‹è¡Œæ¸¬è©¦ç¢ºèªå¤±æ•— (Red)
  - [ ] é©—è­‰æ¸¬è©¦è¦†è“‹æ‰€æœ‰å¿«æ·éµå ´æ™¯

### éšæ®µ 4: æœ€å°å¯¦ä½œ (Green Phase)

- [ ] å¯¦ä½œå…¨åŸŸå¿«æ·éµåŠŸèƒ½ (ç¶ ç‡ˆæœ€å°å¯¦ä½œ) (AC: 1-12)
  - [ ] å»ºç«‹ KeyboardShortcutService æœå‹™
  - [ ] å¯¦ä½œå…¨åŸŸå¿«æ·éµç›£è½å™¨
  - [ ] å»ºç«‹ç„¦é»ç®¡ç†å’Œå°èˆªç³»çµ±
  - [ ] å¯¦ä½œå¿«æ·éµèªªæ˜å°è©±æ¡†
  - [ ] é‹è¡Œå‰ç«¯ BDD æ¸¬è©¦ç¢ºèªé€šé (Green)
- [ ] æ•´åˆç¾æœ‰å…ƒä»¶å¿«æ·éµåŠŸèƒ½ (AC: æ‰€æœ‰ç›¸é—œ)
  - [ ] æ•´åˆä»»å‹™åˆ—è¡¨çš„å¿«æ·éµæ”¯æ´
  - [ ] æ•´åˆæœå°‹å’Œæª¢è¦–åˆ‡æ›çš„å¿«æ·éµ
  - [ ] æ•´åˆæ¸…é™¤åŠŸèƒ½çš„å¿«æ·éµ
  - [ ] é‹è¡Œæ•´åˆæ¸¬è©¦ç¢ºèªæ‰€æœ‰å ´æ™¯é€šé

### éšæ®µ 5: é‡æ§‹å’Œå¢å¼· (Blue Phase)

- [ ] å„ªåŒ–ç”¨æˆ¶é«”é©—å’Œæ•ˆèƒ½ (AC: 11, 12)
  - [ ] å¯¦ä½œå¿«æ·éµè¦–è¦ºæç¤ºå’Œå·¥å…·æç¤º
  - [ ] å„ªåŒ–å¿«æ·éµå›æ‡‰é€Ÿåº¦å’Œæº–ç¢ºæ€§
  - [ ] å¯¦ä½œè‡ªè¨‚å¿«æ·éµåŠŸèƒ½ï¼ˆå¯é¸ï¼‰
  - [ ] åŠ å¼·ç€è¦½å™¨ç›¸å®¹æ€§è™•ç†
- [ ] ç¨‹å¼ç¢¼é‡æ§‹å’Œæœ€ä½³åŒ–
  - [ ] é‡æ§‹é‡è¤‡ç¨‹å¼ç¢¼å’Œæ”¹å–„æ¶æ§‹
  - [ ] å„ªåŒ–äº‹ä»¶ç›£è½å™¨æ•ˆèƒ½
  - [ ] åŠ å¼·éŒ¯èª¤è™•ç†å’Œé‚Šç•Œæƒ…æ³
  - [ ] ç¢ºä¿ç¨‹å¼ç¢¼ç¬¦åˆå°ˆæ¡ˆç·¨ç¢¼æ¨™æº–

### éšæ®µ 6: å®Œæ•´é©—è­‰ (AC: 1-12)

- [ ] E2E BDD æ¸¬è©¦åŸ·è¡Œ
  - [ ] é‹è¡Œå®Œæ•´çš„å¿«æ·éµåŠŸèƒ½ E2E æ¸¬è©¦
  - [ ] é©—è­‰è·¨ç€è¦½å™¨å¿«æ·éµç›¸å®¹æ€§
  - [ ] æ¸¬è©¦å¿«æ·éµèˆ‡å…¶ä»–åŠŸèƒ½çš„æ•´åˆ
- [ ] å›æ­¸æ¸¬è©¦å’Œå“è³ªç¢ºä¿
  - [ ] ç¢ºèªä¸å½±éŸ¿ç¾æœ‰ Epic 2 å’Œ Story 3.1-3.3 åŠŸèƒ½
  - [ ] é‹è¡Œå®Œæ•´æ¸¬è©¦å¥—ä»¶
  - [ ] é©—è­‰æ‰€æœ‰é©—æ”¶æ¨™æº–é”æˆ

## Dev Notes

### ä¾è³´å‰ä¸€å€‹æ•…äº‹

æ­¤æ•…äº‹å»ºç«‹åœ¨ **Epic 2 å®Œæ•´å¯¦ä½œ** å’Œ **Story 3.1-3.3 åŠŸèƒ½** çš„åŸºç¤ä¸Šï¼š

- éœ€è¦ TodoTask è³‡æ–™æ¨¡å‹å’Œ CRUD åŸºç¤åŠŸèƒ½ (Story 2.1-2.4)
- éœ€è¦å‰ç«¯ TaskService å’Œ TaskListComponent
- éœ€è¦ Angular Signals ç‹€æ…‹ç®¡ç†æ©Ÿåˆ¶
- éœ€è¦æª¢è¦–åˆ‡æ›åŠŸèƒ½ï¼ˆ3.1ï¼‰çš„å¿«æ·éµæ•´åˆ
- éœ€è¦æœå°‹åŠŸèƒ½ï¼ˆ3.2ï¼‰çš„å¿«æ·éµæ•´åˆ
- éœ€è¦æ¸…é™¤åŠŸèƒ½ï¼ˆ3.3ï¼‰çš„å¿«æ·éµæ•´åˆ

### BDD æ¸¬è©¦å ´æ™¯æ¡†æ¶

æ­¤æ•…äº‹åŸºæ–¼ä»¥ä¸‹ BDD æ¸¬è©¦å ´æ™¯å¯¦ä½œï¼š

**ä¸»è¦æ¸¬è©¦å ´æ™¯ï¼š**

```gherkin
Feature: éµç›¤å¿«æ·éµæ”¯æ´
  As a ç”Ÿç”¢åŠ›ä½¿ç”¨è€…
  I want to ä½¿ç”¨éµç›¤å¿«æ·éµæ“ä½œæ‡‰ç”¨ç¨‹å¼
  So that æˆ‘å¯ä»¥æé«˜æ“ä½œæ•ˆç‡

Scenario: æ–°å¢ä»»å‹™å¿«æ·éµ (Ctrl+N)
  Given æˆ‘åœ¨ä»»å‹™é é¢
  When æˆ‘æŒ‰ä¸‹ Ctrl+N
  Then ä»»å‹™è¼¸å…¥æ¡†æ‡‰è©²ç²å¾—ç„¦é»
  And æ¸¸æ¨™æ‡‰è©²åœ¨è¼¸å…¥æ¡†ä¸­

Scenario: æœå°‹ä»»å‹™å¿«æ·éµ (Ctrl+F)
  Given æˆ‘åœ¨ä»»å‹™é é¢
  When æˆ‘æŒ‰ä¸‹ Ctrl+F
  Then æœå°‹è¼¸å…¥æ¡†æ‡‰è©²ç²å¾—ç„¦é»
  And æ¸¸æ¨™æ‡‰è©²åœ¨æœå°‹æ¡†ä¸­

Scenario: ä»»å‹™æ“ä½œå¿«æ·éµ
  Given æˆ‘æœ‰ä»»å‹™ "æ¸¬è©¦ä»»å‹™"
  And ä»»å‹™é …ç›®ç²å¾—ç„¦é»
  When æˆ‘æŒ‰ä¸‹ Space éµ
  Then ä»»å‹™æ‡‰è©²åˆ‡æ›å®Œæˆç‹€æ…‹
  
  When æˆ‘æŒ‰ä¸‹ Enter éµ
  Then ä»»å‹™æ‡‰è©²é€²å…¥ç·¨è¼¯æ¨¡å¼
  
  When æˆ‘æŒ‰ä¸‹ Delete éµ
  Then æ‡‰è©²é¡¯ç¤ºåˆªé™¤ç¢ºèªå°è©±æ¡†

Scenario: æª¢è¦–åˆ‡æ›å¿«æ·éµ (æ•¸å­—éµ)
  Given æˆ‘åœ¨ä»»å‹™é é¢
  When æˆ‘æŒ‰ä¸‹æ•¸å­—éµ "1"
  Then æ‡‰è©²åˆ‡æ›åˆ°ã€Œå¾…è¾¦ã€æª¢è¦–
  When æˆ‘æŒ‰ä¸‹æ•¸å­—éµ "2"
  Then æ‡‰è©²åˆ‡æ›åˆ°ã€Œå·²å®Œæˆã€æª¢è¦–
  When æˆ‘æŒ‰ä¸‹æ•¸å­—éµ "3"
  Then æ‡‰è©²åˆ‡æ›åˆ°ã€Œå…¨éƒ¨ã€æª¢è¦–

Scenario: æ¸…é™¤å·²å®Œæˆä»»å‹™å¿«æ·éµ (Ctrl+D)
  Given æˆ‘æœ‰å·²å®Œæˆä»»å‹™
  When æˆ‘æŒ‰ä¸‹ Ctrl+D
  Then æ‡‰è©²é¡¯ç¤ºæ¸…é™¤ç¢ºèªå°è©±æ¡†

Scenario: å–æ¶ˆæ“ä½œå¿«æ·éµ (Escape)
  Given æˆ‘åœ¨ç·¨è¼¯ä»»å‹™æ¨¡å¼
  When æˆ‘æŒ‰ä¸‹ Escape éµ
  Then æ‡‰è©²å–æ¶ˆç·¨è¼¯ä¸¦æ¢å¾©åŸå§‹ç‹€æ…‹
  
  Given æˆ‘æœ‰é–‹å•Ÿçš„å°è©±æ¡†
  When æˆ‘æŒ‰ä¸‹ Escape éµ
  Then å°è©±æ¡†æ‡‰è©²é—œé–‰

Scenario: Tab éµç„¦é»å°èˆª
  Given æˆ‘åœ¨ä»»å‹™é é¢
  When æˆ‘æŒ‰ä¸‹ Tab éµ
  Then ç„¦é»æ‡‰è©²ç§»å‹•åˆ°ä¸‹ä¸€å€‹å¯äº’å‹•å…ƒç´ 
  When æˆ‘æŒ‰ä¸‹ Shift+Tab
  Then ç„¦é»æ‡‰è©²ç§»å‹•åˆ°ä¸Šä¸€å€‹å¯äº’å‹•å…ƒç´ 

Scenario: å¿«æ·éµèªªæ˜ (Ctrl+? æˆ– F1)
  Given æˆ‘åœ¨ä»»å‹™é é¢
  When æˆ‘æŒ‰ä¸‹ Ctrl+?
  Then æ‡‰è©²é¡¯ç¤ºå¿«æ·éµèªªæ˜å°è©±æ¡†
  And èªªæ˜æ‡‰è©²åˆ—å‡ºæ‰€æœ‰å¯ç”¨å¿«æ·éµ

Scenario: å¿«æ·éµè¡çªè™•ç†
  Given æˆ‘åœ¨æ–‡å­—è¼¸å…¥æ¡†ä¸­
  When æˆ‘æŒ‰ä¸‹ Ctrl+A
  Then æ‡‰è©²å…¨é¸æ–‡å­—å…§å®¹
  And ä¸æ‡‰è©²è§¸ç™¼æ‡‰ç”¨ç¨‹å¼çš„å…¨é¸åŠŸèƒ½

Scenario: ç€è¦½å™¨ç›¸å®¹æ€§
  Given æˆ‘ä½¿ç”¨ä¸åŒç€è¦½å™¨ï¼ˆChrome, Firefox, Safari, Edgeï¼‰
  When æˆ‘ä½¿ç”¨å„ç¨®å¿«æ·éµ
  Then æ‰€æœ‰å¿«æ·éµæ‡‰è©²ä¸€è‡´é‹ä½œ
  And ä¸æ‡‰è©²èˆ‡ç€è¦½å™¨é»˜èªè¡Œç‚ºè¡çª

Scenario: å¿«æ·éµè¦–è¦ºæç¤º
  Given æˆ‘å°‡æ»‘é¼ æ‡¸åœåœ¨æŒ‰éˆ•ä¸Š
  Then æ‡‰è©²é¡¯ç¤ºå°æ‡‰çš„å¿«æ·éµæç¤º
  
  Given æˆ‘é–‹å•Ÿå¿«æ·éµèªªæ˜
  Then æ‡‰è©²çœ‹åˆ°æ¸…æ¥šçš„å¿«æ·éµåœ–è¡¨
```

### æ¶æ§‹è¨­è¨ˆè€ƒé‡ [Source: architecture.md]

**å‰ç«¯å¿«æ·éµæ¶æ§‹è¨­è¨ˆï¼š**

```typescript
// å¿«æ·éµæœå‹™
@Injectable({ providedIn: "root" })
export class KeyboardShortcutService {
  private shortcuts = new Map<string, ShortcutHandler>();
  private isListening = signal<boolean>(false);
  private currentFocus = signal<HTMLElement | null>(null);

  constructor(
    private focusManager: FocusManagerService,
    private taskService: TaskService,
    private viewStateService: ViewStateService,
    private clearService: ClearCompletedService
  ) {
    this.initializeShortcuts();
  }

  ngOnInit() {
    this.startListening();
  }

  private initializeShortcuts(): void {
    // è¨»å†Šæ‰€æœ‰å¿«æ·éµ
    this.registerShortcut('ctrl+n', this.focusNewTaskInput.bind(this));
    this.registerShortcut('ctrl+f', this.focusSearchInput.bind(this));
    this.registerShortcut('ctrl+d', this.clearCompletedTasks.bind(this));
    this.registerShortcut('ctrl+?', this.showHelp.bind(this));
    this.registerShortcut('f1', this.showHelp.bind(this));
    this.registerShortcut('escape', this.cancelCurrentAction.bind(this));
    this.registerShortcut('space', this.toggleTaskCompletion.bind(this));
    this.registerShortcut('enter', this.editFocusedTask.bind(this));
    this.registerShortcut('delete', this.deleteFocusedTask.bind(this));
    this.registerShortcut('1', this.switchToTodoView.bind(this));
    this.registerShortcut('2', this.switchToCompletedView.bind(this));
    this.registerShortcut('3', this.switchToAllView.bind(this));
  }

  private registerShortcut(combination: string, handler: ShortcutHandler): void {
    this.shortcuts.set(combination, handler);
  }

  private startListening(): void {
    if (this.isListening()) return;

    document.addEventListener('keydown', this.handleKeyDown.bind(this));
    this.isListening.set(true);
  }

  private handleKeyDown(event: KeyboardEvent): void {
    const combination = this.getKeyCombination(event);
    const handler = this.shortcuts.get(combination);

    if (handler && this.shouldExecuteShortcut(event)) {
      event.preventDefault();
      handler(event);
    }
  }

  private getKeyCombination(event: KeyboardEvent): string {
    const parts: string[] = [];
    
    if (event.ctrlKey) parts.push('ctrl');
    if (event.shiftKey) parts.push('shift');
    if (event.altKey) parts.push('alt');
    if (event.metaKey) parts.push('meta');
    
    parts.push(event.key.toLowerCase());
    
    return parts.join('+');
  }

  private shouldExecuteShortcut(event: KeyboardEvent): boolean {
    const target = event.target as HTMLElement;
    const tagName = target.tagName.toLowerCase();
    
    // åœ¨è¼¸å…¥æ¡†ä¸­æ™‚ï¼ŒåªåŸ·è¡Œç‰¹å®šå¿«æ·éµ
    if (tagName === 'input' || tagName === 'textarea') {
      const allowedInInput = ['escape', 'ctrl+a', 'ctrl+?', 'f1'];
      return allowedInInput.includes(this.getKeyCombination(event));
    }
    
    return true;
  }

  // å¿«æ·éµè™•ç†å™¨å¯¦ä½œ
  private focusNewTaskInput(): void {
    this.focusManager.focusElement('[data-testid="task-input"]');
  }

  private focusSearchInput(): void {
    this.focusManager.focusElement('[data-testid="search-input"]');
  }

  private clearCompletedTasks(): void {
    this.clearService.showConfirmDialog();
  }

  private showHelp(): void {
    this.focusManager.showShortcutHelp();
  }

  private cancelCurrentAction(): void {
    this.focusManager.cancelCurrentAction();
  }

  private toggleTaskCompletion(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      const taskId = parseInt(focusedTask.dataset['taskId']);
      this.taskService.toggleTaskCompletion(taskId);
    }
  }

  private editFocusedTask(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      this.focusManager.enterEditMode(focusedTask);
    }
  }

  private deleteFocusedTask(): void {
    const focusedTask = this.currentFocus();
    if (focusedTask?.dataset['taskId']) {
      const taskId = parseInt(focusedTask.dataset['taskId']);
      this.taskService.showDeleteConfirmation(taskId);
    }
  }

  private switchToTodoView(): void {
    this.viewStateService.setView(TaskViewType.TODO);
  }

  private switchToCompletedView(): void {
    this.viewStateService.setView(TaskViewType.COMPLETED);
  }

  private switchToAllView(): void {
    this.viewStateService.setView(TaskViewType.ALL);
  }
}

// ç„¦é»ç®¡ç†æœå‹™
@Injectable({ providedIn: "root" })
export class FocusManagerService {
  private focusedElement = signal<HTMLElement | null>(null);
  private modalStack: HTMLElement[] = [];

  focusElement(selector: string): void {
    const element = document.querySelector(selector) as HTMLElement;
    if (element) {
      element.focus();
      this.focusedElement.set(element);
    }
  }

  enterEditMode(taskElement: HTMLElement): void {
    // è§¸ç™¼ä»»å‹™ç·¨è¼¯æ¨¡å¼
    const editEvent = new CustomEvent('enterEdit');
    taskElement.dispatchEvent(editEvent);
  }

  showShortcutHelp(): void {
    // é¡¯ç¤ºå¿«æ·éµèªªæ˜å°è©±æ¡†
    const helpDialog = document.querySelector('[data-testid="shortcut-help"]') as HTMLElement;
    if (helpDialog) {
      helpDialog.style.display = 'block';
      this.modalStack.push(helpDialog);
    }
  }

  cancelCurrentAction(): void {
    // å–æ¶ˆç•¶å‰æ“ä½œï¼ˆé—œé–‰å°è©±æ¡†ã€é€€å‡ºç·¨è¼¯ç­‰ï¼‰
    if (this.modalStack.length > 0) {
      const topModal = this.modalStack.pop();
      if (topModal) {
        topModal.style.display = 'none';
      }
    }
    
    // é€€å‡ºç·¨è¼¯æ¨¡å¼
    const editingElement = document.querySelector('.editing');
    if (editingElement) {
      const cancelEvent = new CustomEvent('cancelEdit');
      editingElement.dispatchEvent(cancelEvent);
    }
  }

  handleTabNavigation(event: KeyboardEvent): void {
    const focusableElements = this.getFocusableElements();
    const currentIndex = Array.from(focusableElements).indexOf(document.activeElement as HTMLElement);
    
    if (event.shiftKey) {
      // Shift+Tab (å‘å‰)
      const previousIndex = currentIndex > 0 ? currentIndex - 1 : focusableElements.length - 1;
      focusableElements[previousIndex]?.focus();
    } else {
      // Tab (å‘å¾Œ)
      const nextIndex = currentIndex < focusableElements.length - 1 ? currentIndex + 1 : 0;
      focusableElements[nextIndex]?.focus();
    }
  }

  private getFocusableElements(): HTMLElement[] {
    const selector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
    return Array.from(document.querySelectorAll(selector)) as HTMLElement[];
  }
}

// å¿«æ·éµé¡å‹å®šç¾©
type ShortcutHandler = (event: KeyboardEvent) => void;

interface ShortcutInfo {
  combination: string;
  description: string;
  category: string;
}
```

### å‰ç«¯å…ƒä»¶è¨­è¨ˆ [Source: architecture.md]

**å¿«æ·éµèªªæ˜å°è©±æ¡†å…ƒä»¶ï¼š**

```typescript
@Component({
  selector: "app-shortcut-help",
  template: `
    <div class="shortcut-help-overlay" *ngIf="isVisible()" (click)="close()">
      <div class="shortcut-help-content" (click)="$event.stopPropagation()">
        <div class="help-header">
          <h2>éµç›¤å¿«æ·éµ</h2>
          <button class="close-btn" (click)="close()" [attr.data-testid]="'close-help'">âœ•</button>
        </div>
        
        <div class="help-body">
          <div class="shortcut-category" *ngFor="let category of shortcutCategories">
            <h3>{{ category.name }}</h3>
            <div class="shortcut-list">
              <div 
                class="shortcut-item" 
                *ngFor="let shortcut of category.shortcuts"
                [attr.data-testid]="'shortcut-' + shortcut.key"
              >
                <div class="shortcut-keys">
                  <span 
                    class="key" 
                    *ngFor="let key of shortcut.keys"
                    [class.modifier]="isModifierKey(key)"
                  >
                    {{ key }}
                  </span>
                </div>
                <div class="shortcut-description">{{ shortcut.description }}</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="help-footer">
          <p class="tip">ğŸ’¡ æç¤ºï¼šå°‡æ»‘é¼ æ‡¸åœåœ¨æŒ‰éˆ•ä¸Šå¯æŸ¥çœ‹å°æ‡‰çš„å¿«æ·éµ</p>
        </div>
      </div>
    </div>
  `,
})
export class ShortcutHelpComponent {
  private isVisible = signal<boolean>(false);

  shortcutCategories = [
    {
      name: 'åŸºæœ¬æ“ä½œ',
      shortcuts: [
        { keys: ['Ctrl', 'N'], description: 'æ–°å¢ä»»å‹™', key: 'new-task' },
        { keys: ['Ctrl', 'F'], description: 'æœå°‹ä»»å‹™', key: 'search' },
        { keys: ['Ctrl', 'D'], description: 'æ¸…é™¤å·²å®Œæˆä»»å‹™', key: 'clear' },
        { keys: ['Esc'], description: 'å–æ¶ˆç•¶å‰æ“ä½œ', key: 'cancel' },
      ]
    },
    {
      name: 'ä»»å‹™æ“ä½œ',
      shortcuts: [
        { keys: ['Space'], description: 'åˆ‡æ›ä»»å‹™å®Œæˆç‹€æ…‹', key: 'toggle' },
        { keys: ['Enter'], description: 'ç·¨è¼¯ä»»å‹™', key: 'edit' },
        { keys: ['Del'], description: 'åˆªé™¤ä»»å‹™', key: 'delete' },
      ]
    },
    {
      name: 'æª¢è¦–åˆ‡æ›',
      shortcuts: [
        { keys: ['1'], description: 'åˆ‡æ›åˆ°å¾…è¾¦æª¢è¦–', key: 'view-todo' },
        { keys: ['2'], description: 'åˆ‡æ›åˆ°å·²å®Œæˆæª¢è¦–', key: 'view-completed' },
        { keys: ['3'], description: 'åˆ‡æ›åˆ°å…¨éƒ¨æª¢è¦–', key: 'view-all' },
      ]
    },
    {
      name: 'å°èˆª',
      shortcuts: [
        { keys: ['Tab'], description: 'ä¸‹ä¸€å€‹å…ƒç´ ', key: 'tab-next' },
        { keys: ['Shift', 'Tab'], description: 'ä¸Šä¸€å€‹å…ƒç´ ', key: 'tab-prev' },
        { keys: ['Ctrl', '?'], description: 'é¡¯ç¤ºæ­¤èªªæ˜', key: 'help' },
      ]
    }
  ];

  constructor(private shortcutService: KeyboardShortcutService) {}

  show(): void {
    this.isVisible.set(true);
  }

  close(): void {
    this.isVisible.set(false);
  }

  isModifierKey(key: string): boolean {
    return ['Ctrl', 'Shift', 'Alt', 'Meta'].includes(key);
  }

  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.close();
    }
  }
}
```

**ä»»å‹™é …ç›®å¿«æ·éµæ•´åˆï¼š**

```typescript
@Component({
  selector: "app-task-item",
  template: `
    <div 
      class="task-item"
      [class.focused]="isFocused()"
      [class.editing]="isEditing()"
      [attr.data-task-id]="task.id"
      [attr.data-testid]="'task-item'"
      [attr.tabindex]="0"
      (focus)="onFocus()"
      (blur)="onBlur()"
      (keydown)="onKeyDown($event)"
      (enterEdit)="startEdit()"
      (cancelEdit)="cancelEdit()"
    >
      <!-- ä»»å‹™å…§å®¹ -->
      <div class="task-content" *ngIf="!isEditing()">
        <input 
          type="checkbox" 
          [checked]="task.isCompleted"
          (change)="toggleCompletion()"
          [attr.data-testid]="'task-checkbox'"
        />
        <span class="task-text" [class.completed]="task.isCompleted">
          {{ task.description }}
        </span>
        <div class="task-actions">
          <button 
            class="edit-btn" 
            (click)="startEdit()"
            [title]="'ç·¨è¼¯ (Enter)'"
            [attr.data-testid]="'edit-button'"
          >
            âœï¸
          </button>
          <button 
            class="delete-btn" 
            (click)="deleteTask()"
            [title]="'åˆªé™¤ (Delete)'"
            [attr.data-testid]="'delete-button'"
          >
            ğŸ—‘ï¸
          </button>
        </div>
      </div>

      <!-- ç·¨è¼¯æ¨¡å¼ -->
      <div class="task-edit" *ngIf="isEditing()">
        <input 
          type="text" 
          [(ngModel)]="editText"
          (keydown)="onEditKeyDown($event)"
          (blur)="saveEdit()"
          [attr.data-testid]="'edit-input'"
          #editInput
        />
      </div>
    </div>
  `,
})
export class TaskItemComponent {
  @Input() task!: Task;
  @Output() taskUpdate = new EventEmitter<Task>();
  @Output() taskDelete = new EventEmitter<number>();

  private isFocused = signal<boolean>(false);
  private isEditing = signal<boolean>(false);
  private editText = signal<string>('');

  onFocus(): void {
    this.isFocused.set(true);
  }

  onBlur(): void {
    this.isFocused.set(false);
  }

  onKeyDown(event: KeyboardEvent): void {
    if (!this.isFocused()) return;

    switch (event.key) {
      case ' ':
        event.preventDefault();
        this.toggleCompletion();
        break;
      case 'Enter':
        event.preventDefault();
        this.startEdit();
        break;
      case 'Delete':
        event.preventDefault();
        this.deleteTask();
        break;
    }
  }

  startEdit(): void {
    this.editText.set(this.task.description);
    this.isEditing.set(true);
    
    // ä¸‹ä¸€å€‹ tick èšç„¦è¼¸å…¥æ¡†
    setTimeout(() => {
      const input = document.querySelector('[data-testid="edit-input"]') as HTMLInputElement;
      input?.focus();
    });
  }

  cancelEdit(): void {
    this.isEditing.set(false);
    this.editText.set('');
  }

  saveEdit(): void {
    if (this.editText().trim() && this.editText() !== this.task.description) {
      const updatedTask = { ...this.task, description: this.editText().trim() };
      this.taskUpdate.emit(updatedTask);
    }
    this.isEditing.set(false);
  }

  onEditKeyDown(event: KeyboardEvent): void {
    switch (event.key) {
      case 'Enter':
        event.preventDefault();
        this.saveEdit();
        break;
      case 'Escape':
        event.preventDefault();
        this.cancelEdit();
        break;
    }
  }

  toggleCompletion(): void {
    const updatedTask = { ...this.task, isCompleted: !this.task.isCompleted };
    this.taskUpdate.emit(updatedTask);
  }

  deleteTask(): void {
    this.taskDelete.emit(this.task.id);
  }
}
```

### CSS è¨­è¨ˆè¦ç¯„

**å¿«æ·éµç›¸é—œæ¨£å¼ï¼š**

```scss
// å¿«æ·éµèªªæ˜å°è©±æ¡†
.shortcut-help-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;

  .shortcut-help-content {
    background: white;
    border-radius: 12px;
    padding: 0;
    max-width: 600px;
    width: 90%;
    max-height: 80vh;
    overflow: auto;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);

    .help-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 24px 24px 0 24px;
      border-bottom: 1px solid #e5e7eb;
      margin-bottom: 24px;

      h2 {
        margin: 0;
        font-size: 24px;
        font-weight: 600;
        color: #111827;
      }

      .close-btn {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        color: #6b7280;
        padding: 8px;
        border-radius: 4px;

        &:hover {
          background: #f3f4f6;
          color: #374151;
        }
      }
    }

    .help-body {
      padding: 0 24px;

      .shortcut-category {
        margin-bottom: 32px;

        h3 {
          font-size: 16px;
          font-weight: 600;
          color: #374151;
          margin: 0 0 16px 0;
          padding-bottom: 8px;
          border-bottom: 1px solid #e5e7eb;
        }

        .shortcut-list {
          display: grid;
          gap: 12px;

          .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;

            .shortcut-keys {
              display: flex;
              gap: 4px;

              .key {
                display: inline-block;
                padding: 4px 8px;
                background: #f3f4f6;
                border: 1px solid #d1d5db;
                border-radius: 4px;
                font-family: monospace;
                font-size: 12px;
                font-weight: 600;
                color: #374151;
                min-width: 20px;
                text-align: center;

                &.modifier {
                  background: #e5e7eb;
                  color: #111827;
                }
              }
            }

            .shortcut-description {
              color: #6b7280;
              font-size: 14px;
            }
          }
        }
      }
    }

    .help-footer {
      padding: 16px 24px 24px 24px;
      border-top: 1px solid #e5e7eb;
      background: #f9fafb;

      .tip {
        margin: 0;
        font-size: 14px;
        color: #6b7280;
        text-align: center;
      }
    }
  }
}

// ä»»å‹™é …ç›®ç„¦é»æ¨£å¼
.task-item {
  outline: none;
  transition: all 0.2s ease;

  &.focused {
    background: #eff6ff;
    border-color: #3b82f6;
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.1);
  }

  &:focus-visible {
    outline: 2px solid #3b82f6;
    outline-offset: 2px;
  }
}

// å¿«æ·éµæç¤ºå·¥å…·æç¤º
.shortcut-tooltip {
  position: absolute;
  background: #374151;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  font-weight: 500;
  white-space: nowrap;
  z-index: 1000;
  pointer-events: none;

  &::after {
    content: '';
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 4px solid transparent;
    border-top-color: #374151;
  }
}

// è¦–è¦ºè¼”åŠ©æŒ‡ç¤ºå™¨
.keyboard-mode {
  .focusable {
    position: relative;

    &::after {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      border: 1px dashed #9ca3af;
      border-radius: 4px;
      opacity: 0.5;
      pointer-events: none;
    }

    &:focus::after {
      border-color: #3b82f6;
      border-style: solid;
      opacity: 1;
    }
  }
}
```

### æ¸¬è©¦è¦æ±‚ [Source: bdd-testing-strategy.md]

**å‰ç«¯ BDD æ¸¬è©¦ï¼š**

- æ¸¬è©¦æª”æ¡ˆï¼š`tests/frontend-bdd/features/keyboard-shortcuts.feature`
- æ­¥é©Ÿå®šç¾©ï¼š`tests/frontend-bdd/step_definitions/keyboard-shortcuts.steps.ts`
- é‡é»æ¸¬è©¦ï¼šæ‰€æœ‰å¿«æ·éµçµ„åˆã€ç„¦é»ç®¡ç†ã€ç€è¦½å™¨ç›¸å®¹æ€§

**E2E BDD æ¸¬è©¦ï¼š**

- å®Œæ•´å¿«æ·éµæµç¨‹æ¸¬è©¦
- è·¨ç€è¦½å™¨å¿«æ·éµç›¸å®¹æ€§æ¸¬è©¦
- èˆ‡å…¶ä»–åŠŸèƒ½çš„æ•´åˆæ¸¬è©¦

### æ•ˆèƒ½è€ƒé‡

**å‰ç«¯æ•ˆèƒ½ï¼š**

- å¿«æ·éµäº‹ä»¶ç›£è½å™¨æ•ˆèƒ½æœ€ä½³åŒ–
- ç„¦é»ç®¡ç†çš„è¨˜æ†¶é«”ä½¿ç”¨
- å¤§é‡å¿«æ·éµè¨»å†Šçš„æ•ˆèƒ½å½±éŸ¿

**ç„¡éšœç¤™æ€§ï¼š**

- è¢å¹•é–±è®€å™¨ç›¸å®¹æ€§
- é«˜å°æ¯”åº¦æ¨¡å¼æ”¯æ´
- éµç›¤å°èˆªçš„é‚è¼¯é †åº

### Testing

**æ¸¬è©¦æ¨™æº–ï¼š** [Source: bdd-testing-strategy.md]

- å‰ç«¯æ¸¬è©¦ï¼šJasmine + Karma (Angular é è¨­)
- BDD æ¸¬è©¦ï¼šCucumber (å‰ç«¯)
- E2E æ¸¬è©¦ï¼šSelenium WebDriver
- ç„¡éšœç¤™æ¸¬è©¦ï¼šaxe-core

**æ­¤æ•…äº‹çš„ç‰¹å®šæ¸¬è©¦éœ€æ±‚ï¼š**

- æ‰€æœ‰å¿«æ·éµçµ„åˆåŠŸèƒ½æ¸¬è©¦
- ç„¦é»ç®¡ç†å’Œå°èˆªæ¸¬è©¦
- å¿«æ·éµè¡çªå’Œå„ªå…ˆç´šæ¸¬è©¦
- ç€è¦½å™¨ç›¸å®¹æ€§æ¸¬è©¦
- ç„¡éšœç¤™åŠŸèƒ½ç›¸å®¹æ€§æ¸¬è©¦
- å¿«æ·éµèªªæ˜å°è©±æ¡†æ¸¬è©¦

## Change Log

| Date       | Version | Description                                   | Author       |
| ---------- | ------- | --------------------------------------------- | ------------ |
| 2025-08-21 | 1.0     | åˆå§‹æ•…äº‹å»ºç«‹ï¼ŒåŒ…å«å®Œæ•´ BDD å ´æ™¯æ¡†æ¶å’Œå¯¦ä½œæŒ‡å° | Scrum Master |

## Dev Agent Record

### Agent Model Used

_å¾…é–‹ç™¼ä»£ç†å¡«å¯«_

### Debug Log References

_å¾…é–‹ç™¼ä»£ç†å¡«å¯«_

### Completion Notes List

_å¾…é–‹ç™¼ä»£ç†å¡«å¯«_

### File List

_å¾…é–‹ç™¼ä»£ç†å¡«å¯«_

## QA Results

_å¾… QA ä»£ç†å¡«å¯«_