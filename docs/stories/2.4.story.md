# Story 2.4: 刪除任務功能

## Status
Draft

## Story
**As a** 生產力使用者，
**I want** 刪除不需要的任務項目，
**so that** 我可以保持待辦清單整潔並移除不再相關的任務。

## Acceptance Criteria
1. 每個任務項目都有刪除按鈕（滑鼠懸停時顯示）
2. 點擊刪除按鈕時顯示確認對話框
3. 確認對話框包含任務描述和「確認刪除」、「取消」選項
4. 點擊「確認刪除」永久移除任務並更新列表
5. 點擊「取消」或按 Escape 鍵取消刪除操作
6. 刪除操作即時同步到後端 API 和資料庫
7. 任務成功刪除後顯示確認訊息（3秒後自動消失）
8. 任務計數器即時更新，正確顯示剩餘任務數量
9. 網路錯誤時顯示錯誤訊息並保持任務不變
10. 支援鍵盤操作（Delete 鍵刪除選中的任務）
11. 刪除動畫效果（任務淡出並從列表移除）
12. 刪除操作記錄到系統日誌（包含任務 ID 和描述）
13. 已完成任務和待辦任務都可以被刪除
14. 刪除最後一個任務時顯示空狀態提示

## Tasks / Subtasks
- [ ] 實作後端刪除 CQRS 命令處理 (AC: 6, 12)
  - [ ] 建立 DeleteTaskCommand 命令
  - [ ] 實作 DeleteTaskCommandHandler
  - [ ] 建立 DeleteTaskCommandValidator 驗證器
  - [ ] 新增系統日誌記錄功能
- [ ] 實作 REST API 端點 (AC: 6, 9)
  - [ ] 在 TasksController 新增 DELETE /api/tasks/{id} 端點
  - [ ] 實作任務存在性驗證邏輯
  - [ ] 新增刪除錯誤處理機制
  - [ ] 確保資料庫事務完整性
- [ ] 擴展前端任務服務 (AC: 6, 9)
  - [ ] 在 TaskService 新增 deleteTask API 方法
  - [ ] 實作樂觀刪除和錯誤回滾機制
  - [ ] 新增載入狀態管理
  - [ ] 實作重試機制
- [ ] 實作刪除按鈕 UI 元件 (AC: 1, 11)
  - [ ] 在 TaskListComponent 新增刪除按鈕
  - [ ] 實作滑鼠懸停顯示/隱藏邏輯
  - [ ] 新增刪除按鈕圖示和樣式
  - [ ] 實作刪除動畫效果
- [ ] 實作確認對話框元件 (AC: 2, 3, 4, 5)
  - [ ] 建立 ConfirmDialog 可重用元件
  - [ ] 實作對話框顯示/隱藏邏輯
  - [ ] 新增確認和取消按鈕處理
  - [ ] 實作 Escape 鍵取消功能
- [ ] 實作任務列表更新邏輯 (AC: 8, 13, 14)
  - [ ] 更新 TaskListComponent 刪除後狀態
  - [ ] 實作任務計數即時更新
  - [ ] 新增空狀態提示顯示
  - [ ] 確保已完成和待辦任務都可刪除
- [ ] 實作用戶回饋機制 (AC: 7, 9)
  - [ ] 建立 ToastNotification 元件
  - [ ] 實作成功刪除確認訊息
  - [ ] 新增錯誤訊息顯示
  - [ ] 實作訊息自動消失功能
- [ ] 實作鍵盤操作支援 (AC: 10)
  - [ ] 新增 Delete 鍵事件監聽
  - [ ] 實作任務選擇/焦點管理
  - [ ] 新增鍵盤刪除確認流程
  - [ ] 確保鍵盤操作無障礙性
- [ ] 整合前後端功能測試 (AC: 1-14)
  - [ ] 測試完整的刪除流程
  - [ ] 驗證確認對話框功能
  - [ ] 測試錯誤處理和回滾機制
  - [ ] 確認日誌記錄和狀態更新

## Dev Notes

### 依賴前一個故事
此故事依賴 **Story 2.1、2.2、2.3** 的完成：
- 需要 TodoTask 資料模型和資料庫結構
- 需要基本的 CQRS 架構和 MediatR 配置
- 需要 TasksController 和基本 API 結構
- 需要前端 TaskService 和基本元件結構
- 需要任務狀態管理和編輯功能的 UI 基礎

### BDD 測試場景框架
此故事基於以下 BDD 測試場景實作：

**主要測試場景：**
```gherkin
Feature: 刪除任務功能
  As a 生產力使用者
  I want to 刪除不需要的任務
  So that 我可以保持清單整潔

Scenario: 顯示刪除按鈕
  Given 我有一個任務 "要刪除的任務"
  When 我將滑鼠懸停在任務項目上
  Then 應該顯示刪除按鈕
  And 刪除按鈕應該有垃圾桶圖示
  And 刪除按鈕應該有適當的提示文字

Scenario: 透過確認對話框刪除任務
  Given 我有一個任務 "測試任務刪除"
  When 我點擊任務的刪除按鈕
  Then 應該顯示確認對話框
  And 對話框應該包含任務描述 "測試任務刪除"
  And 對話框應該有 "確認刪除" 按鈕
  And 對話框應該有 "取消" 按鈕

  When 我點擊 "確認刪除" 按鈕
  Then 任務應該從列表中移除
  And 應該播放刪除動畫
  And 應該顯示成功訊息 "任務已刪除"
  And 任務計數應該減少 1

Scenario: 取消刪除操作
  Given 我有一個任務 "不要刪除的任務"
  When 我點擊任務的刪除按鈕
  And 確認對話框顯示
  And 我點擊 "取消" 按鈕
  Then 對話框應該消失
  And 任務應該保持在列表中
  And 任務計數應該不變

Scenario: 使用 Escape 鍵取消刪除
  Given 我有一個任務 "保留任務"
  When 我點擊任務的刪除按鈕
  And 確認對話框顯示
  And 我按下 Escape 鍵
  Then 對話框應該消失
  And 任務應該保持在列表中

Scenario: 使用鍵盤刪除任務
  Given 我有一個任務 "鍵盤刪除測試"
  And 任務項目獲得焦點
  When 我按下 Delete 鍵
  Then 應該顯示確認對話框
  
  When 我按下 Enter 鍵確認
  Then 任務應該被刪除
  And 應該顯示成功訊息

Scenario: 網路錯誤時刪除失敗
  Given 我有一個任務 "網路錯誤測試"
  When API 服務無法回應
  And 我嘗試刪除任務
  And 我確認刪除操作
  Then 應該顯示錯誤訊息 "刪除失敗，請重試"
  And 任務應該保持在列表中
  And 任務計數應該不變

Scenario: 刪除已完成和待辦任務
  Given 我有以下任務：
    | 任務描述        | 狀態  |
    | 待辦任務測試    | 待辦  |
    | 已完成任務測試  | 已完成 |
  When 我刪除待辦任務 "待辦任務測試"
  Then 任務應該被成功刪除
  
  When 我刪除已完成任務 "已完成任務測試"
  Then 任務應該被成功刪除
  And 總任務數應該為 0

Scenario: 刪除最後一個任務顯示空狀態
  Given 我只有一個任務 "最後的任務"
  When 我刪除這個任務
  And 我確認刪除操作
  Then 任務應該被刪除
  And 應該顯示空狀態提示 "還沒有任務，新增一個開始吧！"
  And 任務計數應該顯示 "0 個任務"

Scenario: 刪除操作系統日誌記錄
  Given 我有一個任務 ID 為 123 的任務 "要記錄的任務"
  When 我刪除這個任務
  And 我確認刪除操作
  Then 任務應該被刪除
  And 系統日誌應該記錄 "Task deleted: ID=123, Description=要記錄的任務"
```

### 擴展現有資料模型 [Source: Story 2.1 - TodoTask 實體]
**現有的 TodoTask 實體無需修改，刪除操作直接移除記錄：**
```csharp
public class TodoTask
{
    public int Id { get; set; }
    public string Description { get; set; } = string.Empty;
    public bool IsCompleted { get; set; } = false;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}
```

### CQRS 擴展實作 [Source: architecture.md#CQRS 實作指導原則]
**DeleteTaskCommand 結構：**
```csharp
public class DeleteTaskCommand : IRequest<bool>
{
    public int TaskId { get; set; }
}

public class DeleteTaskCommandValidator : AbstractValidator<DeleteTaskCommand>
{
    public DeleteTaskCommandValidator()
    {
        RuleFor(x => x.TaskId)
            .GreaterThan(0).WithMessage("任務 ID 必須大於 0");
    }
}

public class DeleteTaskCommandHandler : IRequestHandler<DeleteTaskCommand, bool>
{
    private readonly ITaskRepository _repository;
    private readonly ILogger<DeleteTaskCommandHandler> _logger;
    
    public DeleteTaskCommandHandler(
        ITaskRepository repository, 
        ILogger<DeleteTaskCommandHandler> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<bool> Handle(DeleteTaskCommand request, CancellationToken cancellationToken)
    {
        var task = await _repository.GetByIdAsync(request.TaskId);
        if (task == null)
            throw new NotFoundException($"找不到 ID 為 {request.TaskId} 的任務");
            
        // 記錄刪除操作到系統日誌
        _logger.LogInformation("Task deleted: ID={TaskId}, Description={Description}", 
            task.Id, task.Description);
            
        var result = await _repository.DeleteAsync(task.Id);
        return result;
    }
}
```

### Repository 擴展 [Source: architecture.md#Repository 模式指導原則]
**ITaskRepository 新增刪除方法：**
```csharp
public interface ITaskRepository
{
    // 現有方法
    Task<TodoTask> GetByIdAsync(int id);
    Task<TodoTask> CreateAsync(TodoTask task);
    Task<TodoTask> UpdateAsync(TodoTask task);
    
    // 新增刪除方法
    Task<bool> DeleteAsync(int id);
}

public class TaskRepository : ITaskRepository
{
    private readonly AppDbContext _context;

    public TaskRepository(AppDbContext context)
    {
        _context = context;
    }

    public async Task<bool> DeleteAsync(int id)
    {
        var task = await _context.Tasks.FindAsync(id);
        if (task == null)
            return false;

        _context.Tasks.Remove(task);
        var result = await _context.SaveChangesAsync();
        return result > 0;
    }
}
```

### API 端點擴展 [Source: architecture.md#API 控制器指導原則]
**新增 API 端點：**
- 端點：`DELETE /api/tasks/{id}`
- 成功回應：`204 No Content`（標準 REST 刪除回應）
- 錯誤回應：`404 Not Found`（任務不存在）

```csharp
[HttpDelete("{id}")]
public async Task<ActionResult> DeleteTask(int id)
{
    var command = new DeleteTaskCommand { TaskId = id };
    
    try
    {
        var result = await _mediator.Send(command);
        if (result)
            return NoContent(); // 204 - 成功刪除
        else
            return NotFound($"找不到 ID 為 {id} 的任務");
    }
    catch (NotFoundException)
    {
        return NotFound($"找不到 ID 為 {id} 的任務");
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "刪除任務 {TaskId} 時發生錯誤", id);
        return StatusCode(500, "刪除任務時發生內部錯誤");
    }
}
```

### 前端服務擴展 [Source: architecture.md#狀態管理策略]
**TaskService 新增刪除方法：**
```typescript
export interface TaskService {
  // 現有方法
  createTask(description: string): Observable<Task>;
  updateTaskStatus(taskId: number, isCompleted: boolean): Observable<Task>;
  updateTaskDescription(taskId: number, newDescription: string): Observable<Task>;
  
  // 新增刪除方法
  deleteTask(taskId: number): Observable<boolean>;
}

// 實作樂觀刪除和錯誤回滾
deleteTask(taskId: number): Observable<boolean> {
  // 先樂觀地從本地狀態移除任務
  const taskToDelete = this.getTaskById(taskId);
  if (taskToDelete) {
    this.removeTaskFromState(taskId);
  }

  return this.http.delete(`/api/tasks/${taskId}`, { observe: 'response' })
    .pipe(
      map(response => response.status === 204),
      tap(success => {
        if (success) {
          this.showSuccessMessage('任務已刪除');
        }
      }),
      catchError(error => {
        // 錯誤時恢復任務到狀態中
        if (taskToDelete) {
          this.addTaskToState(taskToDelete);
        }
        this.showErrorMessage('刪除失敗，請重試');
        return throwError(() => error);
      })
    );
}
```

### 前端元件實作 [Source: architecture.md#前端架構]
**ConfirmDialog 可重用元件：**
```typescript
@Component({
  selector: 'app-confirm-dialog',
  template: `
    <div class="dialog-backdrop" *ngIf="isVisible" (click)="onBackdropClick()">
      <div class="dialog-container" (click)="$event.stopPropagation()">
        <h3>{{ title }}</h3>
        <p>{{ message }}</p>
        <div class="dialog-actions">
          <button class="btn-cancel" (click)="onCancel()">取消</button>
          <button class="btn-confirm" (click)="onConfirm()">確認刪除</button>
        </div>
      </div>
    </div>
  `,
  styleUrls: ['./confirm-dialog.component.scss']
})
export class ConfirmDialogComponent {
  @Input() isVisible = false;
  @Input() title = '確認操作';
  @Input() message = '';
  @Output() confirmed = new EventEmitter<void>();
  @Output() cancelled = new EventEmitter<void>();

  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.onCancel();
    } else if (event.key === 'Enter') {
      this.onConfirm();
    }
  }

  onConfirm(): void {
    this.confirmed.emit();
  }

  onCancel(): void {
    this.cancelled.emit();
  }

  onBackdropClick(): void {
    this.onCancel();
  }
}
```

**TaskListComponent 擴展刪除功能：**
```typescript
export class TaskListComponent {
  showDeleteConfirm = false;
  taskToDelete: Task | null = null;
  selectedTaskId: number | null = null;

  // 顯示刪除確認對話框
  showDeleteDialog(task: Task): void {
    this.taskToDelete = task;
    this.showDeleteConfirm = true;
  }

  // 確認刪除操作
  confirmDelete(): void {
    if (this.taskToDelete) {
      this.taskService.deleteTask(this.taskToDelete.id).subscribe({
        next: (success) => {
          if (success) {
            this.playDeleteAnimation(this.taskToDelete!.id);
          }
        },
        error: (error) => {
          console.error('刪除失敗:', error);
        }
      });
    }
    this.closeDeleteDialog();
  }

  // 取消刪除操作
  cancelDelete(): void {
    this.closeDeleteDialog();
  }

  // 關閉刪除確認對話框
  closeDeleteDialog(): void {
    this.showDeleteConfirm = false;
    this.taskToDelete = null;
  }

  // 播放刪除動畫
  playDeleteAnimation(taskId: number): void {
    const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
    if (taskElement) {
      taskElement.classList.add('deleting');
      setTimeout(() => {
        // 動畫完成後才真正從 DOM 移除
      }, 300);
    }
  }

  // 鍵盤刪除支援
  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Delete' && this.selectedTaskId) {
      event.preventDefault();
      const task = this.getTaskById(this.selectedTaskId);
      if (task) {
        this.showDeleteDialog(task);
      }
    }
  }

  // 任務項目點擊選擇
  selectTask(taskId: number): void {
    this.selectedTaskId = taskId;
  }
}
```

### HTML 模板結構
**TaskListComponent 模板擴展：**
```html
<div class="task-item" 
     *ngFor="let task of tasks" 
     [attr.data-task-id]="task.id"
     [class.selected]="selectedTaskId === task.id"
     (click)="selectTask(task.id)">
  
  <!-- 任務內容區域 -->
  <div class="task-content">
    <span class="task-text" [class.completed]="task.isCompleted">
      {{ task.description }}
    </span>
  </div>
  
  <!-- 操作按鈕區域 -->
  <div class="task-actions">
    <button class="delete-btn"
            (click)="showDeleteDialog(task)"
            title="刪除任務"
            [attr.data-testid]="'delete-button'">
      <i class="fas fa-trash"></i>
    </button>
  </div>
</div>

<!-- 確認刪除對話框 -->
<app-confirm-dialog
  [isVisible]="showDeleteConfirm"
  title="確認刪除任務"
  [message]="'確定要刪除任務「' + taskToDelete?.description + '」嗎？此操作無法撤銷。'"
  (confirmed)="confirmDelete()"
  (cancelled)="cancelDelete()"
  [attr.data-testid]="'delete-confirm-dialog'">
</app-confirm-dialog>

<!-- 空狀態提示 -->
<div class="empty-state" *ngIf="tasks.length === 0" [attr.data-testid]="'empty-state'">
  <i class="fas fa-clipboard-list empty-icon"></i>
  <h3>還沒有任務</h3>
  <p>新增一個任務開始吧！</p>
</div>
```

### CSS 樣式設計
**刪除功能視覺效果：**
```scss
.task-item {
  position: relative;
  display: flex;
  align-items: center;
  padding: 12px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  margin-bottom: 8px;
  transition: all 0.2s ease;
  
  &:hover {
    background-color: #f9fafb;
    
    .task-actions {
      opacity: 1;
    }
  }
  
  &.selected {
    border-color: #3b82f6;
    background-color: #eff6ff;
  }
  
  &.deleting {
    animation: slideOutAndFade 0.3s ease-in-out forwards;
  }
}

.task-content {
  flex: 1;
  min-width: 0;
}

.task-actions {
  opacity: 0;
  transition: opacity 0.2s ease;
  margin-left: 12px;
}

.delete-btn {
  background: none;
  border: none;
  color: #ef4444;
  cursor: pointer;
  padding: 8px;
  border-radius: 4px;
  transition: all 0.2s ease;
  
  &:hover {
    background-color: #fee2e2;
    color: #dc2626;
  }
  
  &:focus {
    outline: 2px solid #ef4444;
    outline-offset: 2px;
  }
}

@keyframes slideOutAndFade {
  0% { 
    opacity: 1; 
    transform: translateX(0);
    max-height: 60px;
  }
  50% { 
    opacity: 0.5; 
    transform: translateX(20px);
  }
  100% { 
    opacity: 0; 
    transform: translateX(100%);
    max-height: 0;
    margin-bottom: 0;
    padding: 0;
  }
}

// 確認對話框樣式
.dialog-backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.dialog-container {
  background: white;
  padding: 24px;
  border-radius: 8px;
  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
  max-width: 400px;
  width: 90%;
  
  h3 {
    margin: 0 0 16px 0;
    color: #111827;
    font-size: 18px;
  }
  
  p {
    margin: 0 0 24px 0;
    color: #6b7280;
    line-height: 1.5;
  }
}

.dialog-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  
  button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s ease;
    
    &.btn-cancel {
      background: #f3f4f6;
      color: #374151;
      
      &:hover {
        background: #e5e7eb;
      }
    }
    
    &.btn-confirm {
      background: #ef4444;
      color: white;
      
      &:hover {
        background: #dc2626;
      }
    }
  }
}

// 空狀態樣式
.empty-state {
  text-align: center;
  padding: 48px 24px;
  color: #6b7280;
  
  .empty-icon {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
  }
  
  h3 {
    margin: 0 0 8px 0;
    font-size: 20px;
    color: #374151;
  }
  
  p {
    margin: 0;
    opacity: 0.8;
  }
}
```

### ToastNotification 元件 [新增]
**通知訊息元件：**
```typescript
@Component({
  selector: 'app-toast-notification',
  template: `
    <div class="toast-container" *ngIf="notifications.length > 0">
      <div *ngFor="let notification of notifications" 
           class="toast"
           [ngClass]="'toast-' + notification.type">
        <i class="toast-icon" [ngClass]="getIconClass(notification.type)"></i>
        <span class="toast-message">{{ notification.message }}</span>
        <button class="toast-close" (click)="removeNotification(notification.id)">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>
  `,
  styleUrls: ['./toast-notification.component.scss']
})
export class ToastNotificationComponent {
  notifications: ToastNotification[] = [];

  showNotification(message: string, type: 'success' | 'error' | 'info' = 'info', duration = 3000): void {
    const notification: ToastNotification = {
      id: Date.now(),
      message,
      type,
      timestamp: new Date()
    };

    this.notifications.push(notification);

    if (duration > 0) {
      setTimeout(() => {
        this.removeNotification(notification.id);
      }, duration);
    }
  }

  removeNotification(id: number): void {
    this.notifications = this.notifications.filter(n => n.id !== id);
  }

  getIconClass(type: string): string {
    switch (type) {
      case 'success': return 'fas fa-check-circle';
      case 'error': return 'fas fa-exclamation-circle';
      default: return 'fas fa-info-circle';
    }
  }
}

interface ToastNotification {
  id: number;
  message: string;
  type: 'success' | 'error' | 'info';
  timestamp: Date;
}
```

### 測試要求 [Source: bdd-testing-strategy.md]
**前端 BDD 測試：**
- 測試檔案：`tests/frontend-bdd/features/task-deletion.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/task-deletion.steps.ts`
- 重點測試：刪除按鈕顯示、確認對話框、動畫效果、鍵盤操作

**後端 BDD 測試：**
- 測試檔案：`tests/backend-bdd/Features/TaskDeletion.feature`
- 步驟定義：`tests/backend-bdd/StepDefinitions/TaskDeletionSteps.cs`
- 重點測試：DELETE API、資料驗證、日誌記錄、錯誤處理

**E2E BDD 測試：**
- 完整刪除流程測試
- 多任務刪除場景
- 空狀態顯示驗證
- 錯誤恢復測試

### 效能考量
**前端效能：**
- 刪除動畫使用 CSS transforms 避免重排
- 樂觀刪除立即更新 UI，減少感知延遲
- 確認對話框使用 OnPush 變更檢測

**後端效能：**
- 軟刪除 vs 硬刪除策略考量（當前實作為硬刪除）
- 資料庫索引優化刪除查詢
- 批量刪除支援（未來擴展）

### 安全性考量
**授權檢查：**
- 確保只能刪除屬於當前使用者的任務（未來多用戶功能）
- API 端點輸入驗證和清理

**資料保護：**
- 刪除操作日誌記錄
- 考慮實作軟刪除以支援恢復功能

### 無障礙性支援
**鍵盤導航：**
- Tab 鍵導航到刪除按鈕
- Delete 鍵刪除選中任務
- Enter 和 Escape 鍵控制確認對話框

**螢幕閱讀器：**
- 適當的 ARIA 標籤和角色
- 刪除確認的語音通知
- 空狀態的可訪問描述

### Testing
**測試標準：** [Source: bdd-testing-strategy.md]
- 前端測試：Jasmine + Karma (Angular 預設)
- 後端測試：xUnit (.NET 標準測試框架)
- BDD 測試：SpecFlow (後端) + Cucumber (前端)
- E2E 測試：SpecFlow + Selenium WebDriver

**此故事的特定測試需求：**
- 刪除按鈕顯示/隱藏邏輯測試
- DeleteTaskCommand 的整合測試
- 確認對話框互動測試
- 刪除動畫和視覺效果測試
- 鍵盤操作測試
- 空狀態顯示測試
- 錯誤處理和回滾機制測試
- 系統日誌記錄測試

**⚠️ DEV 需要補完的關鍵技術細節：**

1. **軟刪除 vs 硬刪除決策** - 需要確認業務需求是否需要刪除恢復功能
2. **批量刪除支援** - 考慮未來是否需要支援選擇多個任務批量刪除
3. **刪除權限控制** - 多用戶場景下的刪除授權機制
4. **審計日誌詳細程度** - 確認需要記錄哪些刪除操作詳細資訊
5. **刪除動畫性能優化** - 大量任務時的動畫效能考量
6. **確認對話框可訪問性** - 確保符合 WCAG 2.1 AA 標準
7. **Toast 通知位置和樣式** - 統一的通知系統設計規範

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-21 | 1.0 | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used
_待開發代理填寫_

### Debug Log References
_待開發代理填寫_

### Completion Notes List
_待開發代理填寫_

### File List
_待開發代理填寫_

## QA Results
_待 QA 代理填寫_