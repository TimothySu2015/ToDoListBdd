# Story 3.5: 資料持久化和錯誤處理功能

## Status

Draft

## Story

**As a** 生產力使用者，
**I want** 應用程式能夠可靠地保存我的資料並優雅地處理錯誤，
**so that** 我可以信任應用程式不會丟失我的任務資料，並在問題發生時得到清晰的指導。

## Acceptance Criteria

1. **本地資料持久化**：前端在離線時暫存操作，上線後自動同步
2. **樂觀更新**：UI 立即回應操作，背景同步到伺服器
3. **網路錯誤處理**：連線失敗時顯示適當錯誤訊息和重試選項
4. **資料衝突解決**：多裝置同時編輯時的衝突檢測和解決
5. **自動重試機制**：網路操作失敗時自動重試（指數退避）
6. **資料備份和恢復**：定期備份任務資料，支援手動匯出/匯入
7. **錯誤記錄**：記錄錯誤日誌並提供使用者回報功能
8. **優雅降級**：API 不可用時切換到唯讀模式
9. **資料完整性檢查**：啟動時驗證本地資料的完整性
10. **同步狀態指示**：清楚顯示資料同步狀態（同步中/已同步/失敗）
11. **離線模式支援**：完全離線時仍可正常使用基本功能
12. **資料遷移**：支援應用程式版本更新時的資料結構遷移

## Tasks / Subtasks

**⚡ 業務功能 Story - 必須遵循 BDD 驅動流程**

### 階段 1: BDD 場景建立 (Story 第一步)

- [ ] 撰寫完整 BDD 場景涵蓋所有持久化和錯誤處理情境 (AC: 1-12)
- [ ] 場景驗證：確保涵蓋主要使用情境、邊界條件和錯誤情況
- [ ] 場景品質檢查：具體、可測試、與功能需求一致

### 階段 2: 技術需求推導 (基於 BDD 場景)

- [ ] 從 BDD 場景推導後端技術需求 (AC: 4, 6, 7, 9, 12)
  - [ ] 分析場景中的 API 需求：版本控制、衝突檢測、備份 API
  - [ ] 設計資料版本和衝突解決機制
  - [ ] 設計錯誤記錄和回報系統
  - [ ] 設計資料遷移和完整性檢查
- [ ] 從 BDD 場景推導前端技術需求 (AC: 1, 2, 3, 5, 8, 10, 11)
  - [ ] 分析場景中的 UI 元件：同步指示器、錯誤通知、離線模式
  - [ ] 設計 DataPersistenceService 和 OfflineManager
  - [ ] 設計錯誤處理和重試機制
  - [ ] 設計本地儲存和同步策略

### 階段 3: 測試先行 (TDD + BDD)

- [ ] 建立後端 BDD 測試 (Red Phase) (AC: 4, 6, 7, 9, 12)
  - [ ] 建立 DataPersistence.feature 文件
  - [ ] 實作 DataPersistenceSteps.cs 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有資料持久化場景
- [ ] 建立前端 BDD 測試 (Red Phase) (AC: 1, 2, 3, 5, 8, 10, 11)
  - [ ] 建立 data-persistence.feature 文件
  - [ ] 實作 data-persistence.steps.ts 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有離線和錯誤處理場景

### 階段 4: 最小實作 (Green Phase)

- [ ] 實作後端資料持久化功能 (綠燈最小實作) (AC: 4, 6, 7, 9, 12)
  - [ ] 建立版本控制和衝突檢測機制
  - [ ] 實作資料備份和恢復 API
  - [ ] 建立錯誤記錄和監控系統
  - [ ] 實作資料遷移和完整性檢查
  - [ ] 運行後端 BDD 測試確認通過 (Green)
- [ ] 實作前端資料持久化功能 (綠燈最小實作) (AC: 1, 2, 3, 5, 8, 10, 11)
  - [ ] 建立 DataPersistenceService 和 OfflineManager
  - [ ] 實作本地儲存和同步機制
  - [ ] 建立錯誤處理和重試系統
  - [ ] 實作同步狀態指示和離線模式
  - [ ] 運行前端 BDD 測試確認通過 (Green)
- [ ] 整合前後端資料持久化功能 (AC: 所有相關)
  - [ ] 整合樂觀更新和同步機制
  - [ ] 實作完整的錯誤處理流程
  - [ ] 整合所有現有功能的資料持久化
  - [ ] 運行整合測試確認所有場景通過

### 階段 5: 重構和增強 (Blue Phase)

- [ ] 優化用戶體驗和效能 (AC: 2, 5, 10)
  - [ ] 實作先進的衝突解決 UI
  - [ ] 優化同步效能和網路使用
  - [ ] 實作詳細的錯誤診斷工具
  - [ ] 加強離線功能和使用者指導
- [ ] 程式碼重構和最佳化
  - [ ] 重構重複程式碼和改善架構
  - [ ] 優化本地儲存效能和容量管理
  - [ ] 加強錯誤處理的完整性
  - [ ] 確保程式碼符合專案編碼標準

### 階段 6: 完整驗證 (AC: 1-12)

- [ ] E2E BDD 測試執行
  - [ ] 運行完整的資料持久化 E2E 測試
  - [ ] 驗證離線/上線切換場景
  - [ ] 測試錯誤恢復和資料完整性
- [ ] 回歸測試和品質確保
  - [ ] 確認不影響現有所有功能
  - [ ] 運行完整測試套件包含壓力測試
  - [ ] 驗證所有驗收標準達成

## Dev Notes

### 依賴前一個故事

此故事建立在 **Epic 2 完整實作** 和 **Story 3.1-3.4 功能** 的基礎上：

- 需要 TodoTask 資料模型和 CRUD 基礎功能 (Story 2.1-2.4)
- 需要基本的 CQRS 架構和 TasksController
- 需要前端 TaskService 和所有元件
- 需要 Angular Signals 狀態管理機制
- 需要檢視切換功能（3.1）的離線支援
- 需要搜尋功能（3.2）的本地快取
- 需要清除功能（3.3）的同步機制
- 需要快捷鍵功能（3.4）的錯誤狀態處理

### BDD 測試場景框架

此故事基於以下 BDD 測試場景實作：

**主要測試場景：**

```gherkin
Feature: 資料持久化和錯誤處理
  As a 生產力使用者
  I want to 可靠的資料保存和錯誤處理
  So that 我可以信任應用程式保護我的資料

Scenario: 離線任務操作和同步
  Given 我有網路連線
  And 我已同步所有任務
  When 我斷開網路連線
  And 我新增任務 "離線任務"
  And 我編輯任務 "現有任務" 為 "已修改任務"
  Then 我應該看到任務立即更新在 UI 中
  And 我應該看到 "離線模式" 指示器
  When 我重新連接網路
  Then 我應該看到 "同步中" 指示器
  And 所有變更應該同步到伺服器
  And 我應該看到 "已同步" 指示器

Scenario: 樂觀更新和錯誤回滾
  Given 我在線上模式
  When 我新增任務 "測試任務"
  Then 任務應該立即顯示在列表中
  And 我應該看到 "同步中" 指示器
  When 伺服器回應錯誤
  Then 我應該看到錯誤訊息 "無法保存任務"
  And 任務應該標記為 "需要重試"
  And 應該顯示 "重試" 按鈕

Scenario: 網路錯誤自動重試
  Given 我新增任務 "重試測試"
  And 伺服器暫時不可用
  When 同步失敗
  Then 應用程式應該自動重試
  And 重試間隔應該遞增（1s, 2s, 4s, 8s）
  And 我應該看到 "正在重試..." 訊息
  When 伺服器恢復正常
  Then 任務應該成功同步
  And 我應該看到 "已同步" 確認

Scenario: 資料衝突檢測和解決
  Given 我在裝置 A 編輯任務 "會議準備"
  And 其他人在裝置 B 同時編輯相同任務
  When 我保存變更
  And 伺服器回應衝突錯誤
  Then 我應該看到衝突解決對話框
  And 對話框應該顯示兩個版本的差異
  When 我選擇保留我的版本
  Then 我的變更應該被保存
  And 其他版本應該被覆蓋

Scenario: 資料備份和恢復
  Given 我有 50 個任務
  When 我觸發手動備份
  Then 應該生成包含所有任務的備份檔案
  And 我應該能夠下載備份檔案
  When 我清空所有資料
  And 我匯入備份檔案
  Then 所有 50 個任務應該恢復
  And 任務狀態和建立時間應該保持正確

Scenario: 應用程式啟動時資料完整性檢查
  Given 本地儲存有損壞的資料
  When 我啟動應用程式
  Then 應該顯示 "正在檢查資料完整性" 訊息
  And 損壞的資料應該被修復或移除
  And 我應該看到 "資料完整性檢查完成" 通知
  When 檢查完成
  Then 應用程式應該正常載入

Scenario: 優雅降級到唯讀模式
  Given API 伺服器完全不可用
  When 我啟動應用程式
  Then 應該顯示 "離線模式 - 僅可檢視" 訊息
  And 我應該能夠檢視現有任務
  And 所有編輯功能應該被禁用
  And 應該顯示 "嘗試重新連線" 按鈕

Scenario: 同步狀態即時顯示
  Given 我有未同步的變更
  Then 我應該看到同步狀態指示器
  And 指示器應該顯示 "3 個變更待同步"
  When 同步開始
  Then 指示器應該顯示 "同步中 (1/3)"
  And 應該有進度條動畫
  When 同步完成
  Then 指示器應該顯示 "已同步" 並在 3 秒後隱藏

Scenario: 錯誤記錄和回報
  Given 發生一個未預期的錯誤
  When 錯誤被捕獲
  Then 應該記錄錯誤詳情到本地日誌
  And 應該顯示 "發生錯誤" 通知
  And 通知應該包含 "回報問題" 按鈕
  When 我點擊 "回報問題"
  Then 應該開啟錯誤回報對話框
  And 對話框應該包含錯誤詳情和步驟重現說明

Scenario: 版本更新資料遷移
  Given 我使用應用程式版本 1.0
  And 我有舊格式的任務資料
  When 應用程式更新到版本 2.0
  And 我啟動應用程式
  Then 應該顯示 "正在升級資料..." 訊息
  And 資料應該遷移到新格式
  And 我應該看到 "資料升級完成" 確認
  When 遷移完成
  Then 所有任務應該在新版本中正常顯示
```

### 架構設計考量 [Source: architecture.md]

**後端資料持久化設計：**

```csharp
// 版本控制和衝突檢測
public class TodoTask
{
    public int Id { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
    public string Version { get; set; } // ETag for conflict detection
    public string LastModifiedBy { get; set; }
}

public class UpdateTaskCommand : IRequest<UpdateTaskResponse>
{
    public int TaskId { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public string ExpectedVersion { get; set; } // For conflict detection
}

public class UpdateTaskResponse
{
    public TaskDto Task { get; set; }
    public bool ConflictDetected { get; set; }
    public TaskDto ConflictingVersion { get; set; }
}

// 資料備份和恢復
public class BackupService
{
    public async Task<BackupData> CreateBackupAsync(string userId)
    {
        var tasks = await _context.Tasks
            .Where(t => t.UserId == userId)
            .ToListAsync();

        return new BackupData
        {
            Version = "1.0",
            CreatedAt = DateTime.UtcNow,
            Tasks = tasks.Select(t => t.ToDto()).ToList(),
            Checksum = CalculateChecksum(tasks)
        };
    }

    public async Task<RestoreResult> RestoreBackupAsync(BackupData backup, string userId)
    {
        // 驗證備份完整性
        if (!ValidateBackup(backup))
        {
            return new RestoreResult { Success = false, Error = "備份檔案損壞" };
        }

        // 清空現有資料並恢復
        using var transaction = await _context.Database.BeginTransactionAsync();
        try
        {
            await _context.Tasks.Where(t => t.UserId == userId).ExecuteDeleteAsync();
            
            var tasks = backup.Tasks.Select(dto => new TodoTask
            {
                Description = dto.Description,
                IsCompleted = dto.IsCompleted,
                CreatedAt = dto.CreatedAt,
                UpdatedAt = dto.UpdatedAt,
                UserId = userId
            });

            _context.Tasks.AddRange(tasks);
            await _context.SaveChangesAsync();
            await transaction.CommitAsync();

            return new RestoreResult { Success = true, RestoredCount = tasks.Count() };
        }
        catch (Exception ex)
        {
            await transaction.RollbackAsync();
            return new RestoreResult { Success = false, Error = ex.Message };
        }
    }
}

// 錯誤記錄系統
public class ErrorLoggingService
{
    public async Task LogErrorAsync(ErrorReport error)
    {
        var logEntry = new ErrorLog
        {
            Timestamp = DateTime.UtcNow,
            Level = error.Level,
            Message = error.Message,
            StackTrace = error.StackTrace,
            UserAgent = error.UserAgent,
            Url = error.Url,
            UserId = error.UserId
        };

        _context.ErrorLogs.Add(logEntry);
        await _context.SaveChangesAsync();

        // 發送到監控系統 (如果配置)
        await _monitoringService.ReportErrorAsync(logEntry);
    }
}
```

**前端資料持久化架構：**

```typescript
// 資料持久化服務
@Injectable({ providedIn: "root" })
export class DataPersistenceService {
  private syncQueue = signal<PendingOperation[]>([]);
  private syncStatus = signal<SyncStatus>(SyncStatus.SYNCED);
  private isOnline = signal<boolean>(navigator.onLine);

  constructor(
    private storageService: LocalStorageService,
    private taskService: TaskService,
    private errorLogger: ErrorLoggingService
  ) {
    this.initializeNetworkMonitoring();
    this.initializePeriodicSync();
  }

  async optimisticUpdate<T>(
    operation: Operation,
    localUpdate: () => T,
    serverSync: () => Promise<T>
  ): Promise<T> {
    // 立即執行本地更新
    const result = localUpdate();
    
    // 將操作加入同步隊列
    this.addToSyncQueue(operation);
    
    // 如果在線，嘗試同步到伺服器
    if (this.isOnline()) {
      this.performServerSync(operation, serverSync);
    }
    
    return result;
  }

  private async performServerSync<T>(
    operation: Operation, 
    serverSync: () => Promise<T>
  ): Promise<void> {
    this.syncStatus.set(SyncStatus.SYNCING);
    
    try {
      await serverSync();
      this.removeFromSyncQueue(operation.id);
      this.updateSyncStatus();
    } catch (error) {
      this.handleSyncError(operation, error);
    }
  }

  private handleSyncError(operation: Operation, error: any): void {
    if (this.isRetryableError(error)) {
      this.scheduleRetry(operation);
    } else {
      this.markOperationAsFailed(operation, error);
      this.errorLogger.logError({
        level: 'ERROR',
        message: 'Sync operation failed',
        operation,
        error
      });
    }
  }

  private scheduleRetry(operation: Operation): void {
    const retryDelay = this.calculateRetryDelay(operation.retryCount);
    
    setTimeout(() => {
      this.retryOperation(operation);
    }, retryDelay);
  }

  private calculateRetryDelay(retryCount: number): number {
    // 指數退避：1s, 2s, 4s, 8s, 16s (最大)
    return Math.min(1000 * Math.pow(2, retryCount), 16000);
  }
}

// 離線管理器
@Injectable({ providedIn: "root" })
export class OfflineManagerService {
  private offlineMode = signal<boolean>(false);
  private pendingChanges = signal<number>(0);

  constructor(
    private persistenceService: DataPersistenceService,
    private notificationService: NotificationService
  ) {
    this.monitorConnectivity();
  }

  private monitorConnectivity(): void {
    window.addEventListener('online', () => {
      this.offlineMode.set(false);
      this.notificationService.showSuccess('已重新連線，正在同步資料...');
      this.persistenceService.syncPendingOperations();
    });

    window.addEventListener('offline', () => {
      this.offlineMode.set(true);
      this.notificationService.showInfo('已離線，變更將在重新連線後同步');
    });
  }

  isOffline(): boolean {
    return this.offlineMode();
  }

  getPendingChangesCount(): number {
    return this.pendingChanges();
  }
}

// 資料完整性檢查器
@Injectable({ providedIn: "root" })
export class DataIntegrityService {
  async checkDataIntegrity(): Promise<IntegrityReport> {
    const report: IntegrityReport = {
      isValid: true,
      issues: [],
      fixedIssues: []
    };

    try {
      // 檢查本地儲存結構
      await this.validateStorageStructure(report);
      
      // 檢查任務資料完整性
      await this.validateTaskData(report);
      
      // 檢查版本相容性
      await this.validateVersion(report);
      
      // 修復發現的問題
      await this.fixIssues(report);
      
    } catch (error) {
      report.isValid = false;
      report.issues.push({
        type: 'CRITICAL_ERROR',
        message: 'Data integrity check failed',
        error
      });
    }

    return report;
  }

  private async validateTaskData(report: IntegrityReport): Promise<void> {
    const tasks = await this.storageService.getAllTasks();
    
    for (const task of tasks) {
      if (!task.id || !task.description) {
        report.issues.push({
          type: 'INVALID_TASK',
          message: `Task missing required fields: ${JSON.stringify(task)}`,
          taskId: task.id
        });
      }
      
      if (task.createdAt && new Date(task.createdAt) > new Date()) {
        report.issues.push({
          type: 'INVALID_DATE',
          message: `Task has future creation date: ${task.id}`,
          taskId: task.id
        });
      }
    }
  }

  private async fixIssues(report: IntegrityReport): Promise<void> {
    for (const issue of report.issues) {
      try {
        switch (issue.type) {
          case 'INVALID_TASK':
            await this.removeInvalidTask(issue.taskId);
            report.fixedIssues.push(issue);
            break;
            
          case 'INVALID_DATE':
            await this.fixTaskDate(issue.taskId);
            report.fixedIssues.push(issue);
            break;
            
          case 'VERSION_MISMATCH':
            await this.migrateData(issue.fromVersion, issue.toVersion);
            report.fixedIssues.push(issue);
            break;
        }
      } catch (error) {
        issue.fixError = error.message;
      }
    }
  }
}

// 衝突解決器
@Injectable({ providedIn: "root" })
export class ConflictResolverService {
  async resolveConflict(
    localVersion: Task, 
    serverVersion: Task
  ): Promise<ConflictResolution> {
    
    return new Promise((resolve) => {
      const conflictDialog = this.dialogService.open(ConflictResolutionComponent, {
        data: {
          localVersion,
          serverVersion,
          onResolve: (resolution: ConflictResolution) => {
            resolve(resolution);
          }
        }
      });
    });
  }
}
```

### 前端元件設計 [Source: architecture.md]

**同步狀態指示器元件：**

```typescript
@Component({
  selector: "app-sync-status",
  template: `
    <div class="sync-status" [class]="syncStatus()">
      <div class="status-indicator">
        <i class="icon" [class]="getIconClass()"></i>
        <span class="status-text">{{ getStatusText() }}</span>
      </div>
      
      <div class="sync-details" *ngIf="shouldShowDetails()">
        <div class="pending-count" *ngIf="pendingCount() > 0">
          {{ pendingCount() }} 個變更待同步
        </div>
        <div class="progress-bar" *ngIf="syncStatus() === 'syncing'">
          <div class="progress" [style.width.%]="syncProgress()"></div>
        </div>
      </div>
      
      <div class="sync-actions" *ngIf="shouldShowActions()">
        <button 
          class="retry-btn"
          *ngIf="syncStatus() === 'error'"
          (click)="retrySync()"
        >
          重試
        </button>
        <button 
          class="force-sync-btn"
          *ngIf="syncStatus() === 'pending'"
          (click)="forceSync()"
        >
          立即同步
        </button>
      </div>
    </div>
  `,
})
export class SyncStatusComponent {
  syncStatus = this.persistenceService.getSyncStatus;
  pendingCount = this.offlineManager.getPendingChangesCount;
  syncProgress = this.persistenceService.getSyncProgress;

  constructor(
    private persistenceService: DataPersistenceService,
    private offlineManager: OfflineManagerService
  ) {}

  getIconClass(): string {
    switch (this.syncStatus()) {
      case 'synced': return 'icon-check';
      case 'syncing': return 'icon-sync spinning';
      case 'pending': return 'icon-clock';
      case 'error': return 'icon-error';
      case 'offline': return 'icon-offline';
      default: return 'icon-question';
    }
  }

  getStatusText(): string {
    switch (this.syncStatus()) {
      case 'synced': return '已同步';
      case 'syncing': return '同步中...';
      case 'pending': return '待同步';
      case 'error': return '同步失敗';
      case 'offline': return '離線模式';
      default: return '未知狀態';
    }
  }

  shouldShowDetails(): boolean {
    return ['syncing', 'pending', 'error'].includes(this.syncStatus());
  }

  shouldShowActions(): boolean {
    return ['error', 'pending'].includes(this.syncStatus());
  }

  retrySync(): void {
    this.persistenceService.retrySyncOperations();
  }

  forceSync(): void {
    this.persistenceService.forceSyncAll();
  }
}
```

**衝突解決對話框元件：**

```typescript
@Component({
  selector: "app-conflict-resolution",
  template: `
    <div class="conflict-dialog">
      <h2>資料衝突</h2>
      <p>這個任務在其他裝置上也被修改了。請選擇要保留的版本：</p>
      
      <div class="conflict-versions">
        <div class="version local-version">
          <h3>您的版本</h3>
          <div class="task-preview">
            <div class="task-description">{{ data.localVersion.description }}</div>
            <div class="task-meta">
              狀態: {{ data.localVersion.isCompleted ? '已完成' : '待辦' }}
              <br>
              修改時間: {{ data.localVersion.updatedAt | date:'short' }}
            </div>
          </div>
          <button 
            class="choose-btn"
            (click)="chooseVersion('local')"
          >
            選擇此版本
          </button>
        </div>
        
        <div class="version server-version">
          <h3>其他裝置的版本</h3>
          <div class="task-preview">
            <div class="task-description">{{ data.serverVersion.description }}</div>
            <div class="task-meta">
              狀態: {{ data.serverVersion.isCompleted ? '已完成' : '待辦' }}
              <br>
              修改時間: {{ data.serverVersion.updatedAt | date:'short' }}
            </div>
          </div>
          <button 
            class="choose-btn"
            (click)="chooseVersion('server')"
          >
            選擇此版本
          </button>
        </div>
      </div>
      
      <div class="manual-merge" *ngIf="showManualMerge">
        <h3>手動合併</h3>
        <textarea 
          [(ngModel)]="mergedDescription"
          placeholder="輸入合併後的任務描述"
        ></textarea>
        <button 
          class="merge-btn"
          (click)="performManualMerge()"
          [disabled]="!mergedDescription.trim()"
        >
          使用合併版本
        </button>
      </div>
      
      <div class="dialog-actions">
        <button class="secondary-btn" (click)="showManualMerge = true">
          手動合併
        </button>
        <button class="cancel-btn" (click)="cancel()">
          取消
        </button>
      </div>
    </div>
  `,
})
export class ConflictResolutionComponent {
  @Inject(MAT_DIALOG_DATA) data: ConflictData;
  
  showManualMerge = false;
  mergedDescription = '';

  constructor(
    private dialogRef: MatDialogRef<ConflictResolutionComponent>
  ) {}

  chooseVersion(version: 'local' | 'server'): void {
    const resolution: ConflictResolution = {
      action: 'choose',
      chosenVersion: version,
      task: version === 'local' ? this.data.localVersion : this.data.serverVersion
    };
    
    this.data.onResolve(resolution);
    this.dialogRef.close();
  }

  performManualMerge(): void {
    const resolution: ConflictResolution = {
      action: 'merge',
      task: {
        ...this.data.localVersion,
        description: this.mergedDescription.trim(),
        updatedAt: new Date()
      }
    };
    
    this.data.onResolve(resolution);
    this.dialogRef.close();
  }

  cancel(): void {
    this.dialogRef.close();
  }
}
```

### CSS 設計規範

**資料持久化相關樣式：**

```scss
// 同步狀態指示器
.sync-status {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  transition: all 0.3s ease;

  &.synced {
    background: #f0fdf4;
    color: #166534;
    border: 1px solid #bbf7d0;
  }

  &.syncing {
    background: #eff6ff;
    color: #1d4ed8;
    border: 1px solid #bfdbfe;
  }

  &.pending {
    background: #fffbeb;
    color: #92400e;
    border: 1px solid #fed7aa;
  }

  &.error {
    background: #fef2f2;
    color: #dc2626;
    border: 1px solid #fecaca;
  }

  &.offline {
    background: #f3f4f6;
    color: #374151;
    border: 1px solid #d1d5db;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;

    .icon {
      width: 16px;
      height: 16px;

      &.spinning {
        animation: spin 1s linear infinite;
      }
    }
  }

  .sync-details {
    display: flex;
    flex-direction: column;
    gap: 4px;

    .pending-count {
      font-size: 12px;
      opacity: 0.8;
    }

    .progress-bar {
      width: 100px;
      height: 4px;
      background: rgba(0, 0, 0, 0.1);
      border-radius: 2px;
      overflow: hidden;

      .progress {
        height: 100%;
        background: currentColor;
        transition: width 0.3s ease;
      }
    }
  }

  .sync-actions {
    display: flex;
    gap: 8px;

    button {
      padding: 4px 8px;
      border: 1px solid currentColor;
      border-radius: 4px;
      background: transparent;
      color: inherit;
      font-size: 12px;
      cursor: pointer;

      &:hover {
        background: currentColor;
        color: white;
      }
    }
  }
}

// 衝突解決對話框
.conflict-dialog {
  padding: 24px;
  max-width: 600px;

  h2 {
    margin: 0 0 16px 0;
    color: #dc2626;
  }

  .conflict-versions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 24px 0;

    .version {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;

      &.local-version {
        border-color: #3b82f6;
        background: #eff6ff;
      }

      &.server-version {
        border-color: #f59e0b;
        background: #fffbeb;
      }

      h3 {
        margin: 0 0 12px 0;
        font-size: 16px;
      }

      .task-preview {
        margin-bottom: 16px;

        .task-description {
          font-weight: 500;
          margin-bottom: 8px;
          padding: 8px;
          background: white;
          border-radius: 4px;
        }

        .task-meta {
          font-size: 12px;
          color: #6b7280;
        }
      }

      .choose-btn {
        width: 100%;
        padding: 8px 16px;
        background: currentColor;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;

        &:hover {
          opacity: 0.9;
        }
      }
    }
  }

  .manual-merge {
    margin: 24px 0;
    padding: 16px;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    background: #f9fafb;

    h3 {
      margin: 0 0 12px 0;
    }

    textarea {
      width: 100%;
      min-height: 80px;
      padding: 8px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      resize: vertical;
    }

    .merge-btn {
      margin-top: 12px;
      padding: 8px 16px;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;

      &:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      &:hover:not(:disabled) {
        background: #059669;
      }
    }
  }

  .dialog-actions {
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 24px;

    button {
      padding: 8px 16px;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      cursor: pointer;

      &.secondary-btn {
        background: white;
        color: #374151;

        &:hover {
          background: #f3f4f6;
        }
      }

      &.cancel-btn {
        background: white;
        color: #6b7280;

        &:hover {
          background: #f3f4f6;
        }
      }
    }
  }
}

// 錯誤通知和重試按鈕
.error-notification {
  background: #fef2f2;
  border: 1px solid #fecaca;
  color: #dc2626;
  padding: 12px 16px;
  border-radius: 6px;
  margin-bottom: 16px;

  .error-message {
    font-weight: 500;
    margin-bottom: 8px;
  }

  .error-actions {
    display: flex;
    gap: 8px;

    button {
      padding: 4px 12px;
      border: 1px solid currentColor;
      border-radius: 4px;
      background: transparent;
      color: inherit;
      font-size: 12px;
      cursor: pointer;

      &:hover {
        background: currentColor;
        color: white;
      }
    }
  }
}

// 離線模式指示器
.offline-banner {
  background: #f3f4f6;
  color: #374151;
  padding: 8px 16px;
  text-align: center;
  border-bottom: 1px solid #e5e7eb;

  .offline-message {
    font-weight: 500;
  }

  .offline-details {
    font-size: 12px;
    opacity: 0.8;
    margin-top: 4px;
  }
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
```

### 測試要求 [Source: bdd-testing-strategy.md]

**前端 BDD 測試：**

- 測試檔案：`tests/frontend-bdd/features/data-persistence.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/data-persistence.steps.ts`
- 重點測試：離線操作、同步機制、錯誤處理、衝突解決

**後端 BDD 測試：**

- 測試檔案：`tests/backend-bdd/Features/DataPersistence.feature`
- 步驟定義：`tests/backend-bdd/StepDefinitions/DataPersistenceSteps.cs`
- 重點測試：版本控制、備份恢復、錯誤記錄、資料遷移

**E2E BDD 測試：**

- 完整離線/上線切換測試
- 資料同步完整性測試
- 錯誤恢復和衝突解決測試

### 效能考量

**前端效能：**

- 本地儲存的容量管理和清理
- 同步隊列的記憶體使用最佳化
- 大量資料的分頁和虛擬化

**後端效能：**

- 資料庫備份和恢復的效能
- 錯誤日誌的儲存和查詢最佳化
- 衝突檢測的查詢效能

### Testing

**測試標準：** [Source: bdd-testing-strategy.md]

- 前端測試：Jasmine + Karma (Angular 預設)
- 後端測試：xUnit (.NET 標準測試框架)
- BDD 測試：SpecFlow (後端) + Cucumber (前端)
- E2E 測試：SpecFlow + Selenium WebDriver
- 壓力測試：大量資料和長時間離線場景

**此故事的特定測試需求：**

- 離線操作完整性測試
- 資料同步準確性測試
- 衝突檢測和解決測試
- 錯誤恢復機制測試
- 資料備份和恢復測試
- 版本遷移功能測試
- 長時間運行穩定性測試

## Change Log

| Date       | Version | Description                                   | Author       |
| ---------- | ------- | --------------------------------------------- | ------------ |
| 2025-08-21 | 1.0     | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_待 QA 代理填寫_