# Story 3.2: 搜尋和篩選任務功能

## Status

Draft

## Story

**As a** 生產力使用者，
**I want** 快速搜尋和篩選我的任務，
**so that** 我可以高效地找到特定的任務並提高工作效率。

## Acceptance Criteria

1. 主頁面顯示搜尋輸入框，在任務列表上方
2. 使用者可以輸入關鍵字即時搜尋任務描述
3. 搜尋結果即時更新，無需按下 Enter 或點擊按鈕
4. 搜尋不區分大小寫，支援部分匹配
5. 搜尋框有明顯的搜尋圖示和 placeholder 文字
6. 搜尋時保持當前的檢視狀態（待辦/已完成/全部）
7. 搜尋結果中匹配的文字應該高亮顯示
8. 當搜尋無結果時顯示「找不到匹配的任務」提示
9. 清空搜尋框時恢復原始的任務列表
10. 搜尋功能應該在 300ms 內回應（防抖動機制）
11. 支援鍵盤快捷鍵 Ctrl+F 快速聚焦搜尋框
12. 搜尋狀態在頁面重新載入後清空

## Tasks / Subtasks

**⚡ 業務功能 Story - 必須遵循 BDD 驅動流程**

### 階段 1: BDD 場景建立 (Story 第一步)

- [ ] 撰寫完整 BDD 場景涵蓋所有搜尋功能情境 (AC: 1-12)
- [ ] 場景驗證：確保涵蓋主要使用情境、邊界條件和錯誤情況
- [ ] 場景品質檢查：具體、可測試、與功能需求一致

### 階段 2: 技術需求推導 (基於 BDD 場景)

- [ ] 從 BDD 場景推導後端技術需求 (AC: 2, 4, 6, 10)
  - [ ] 分析場景中的 API 需求：GET /api/tasks?search=keyword&status=filter
  - [ ] 設計 GetTasksQuery 擴展支援搜尋參數
  - [ ] 設計搜尋邏輯和資料庫查詢最佳化
  - [ ] 定義防抖動和效能考量
- [ ] 從 BDD 場景推導前端技術需求 (AC: 1, 3, 5, 7, 8, 11)
  - [ ] 分析場景中的 UI 元件：搜尋輸入框、高亮顯示
  - [ ] 設計 TaskSearchComponent 元件基於場景互動
  - [ ] 設計即時搜尋和防抖動機制
  - [ ] 設計鍵盤快捷鍵和無障礙功能

### 階段 3: 測試先行 (TDD + BDD)

- [ ] 建立後端 BDD 測試 (Red Phase) (AC: 2, 4, 6, 10)
  - [ ] 建立 TaskSearching.feature 文件
  - [ ] 實作 TaskSearchingSteps.cs 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有搜尋場景
- [ ] 建立前端 BDD 測試 (Red Phase) (AC: 1, 3, 5, 7, 8, 11)
  - [ ] 建立 task-searching.feature 文件
  - [ ] 實作 task-searching.steps.ts 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有 UI 互動場景

### 階段 4: 最小實作 (Green Phase)

- [ ] 實作後端搜尋功能 (綠燈最小實作) (AC: 2, 4, 6, 10)
  - [ ] 擴展 GetTasksQuery 新增 Search 參數
  - [ ] 實作 GetTasksQueryHandler 搜尋邏輯
  - [ ] 更新 TasksController GET 端點支援 search 查詢參數
  - [ ] 實作搜尋的資料庫查詢最佳化
  - [ ] 運行後端 BDD 測試確認通過 (Green)
- [ ] 實作前端搜尋功能 (綠燈最小實作) (AC: 1, 3, 5, 7, 8, 11)
  - [ ] 建立 TaskSearchComponent 元件基礎結構
  - [ ] 實作搜尋輸入框和即時搜尋
  - [ ] 建立 SearchService 管理搜尋狀態
  - [ ] 實作防抖動機制和效能最佳化
  - [ ] 實作高亮顯示和空狀態處理
  - [ ] 運行前端 BDD 測試確認通過 (Green)
- [ ] 整合前後端搜尋功能 (AC: 9, 12)
  - [ ] 擴展 TaskService 新增搜尋方法
  - [ ] 實作搜尋與檢視切換的整合
  - [ ] 實作鍵盤快捷鍵功能
  - [ ] 運行整合測試確認所有場景通過

### 階段 5: 重構和增強 (Blue Phase)

- [ ] 優化用戶體驗和效能 (AC: 7, 10, 11)
  - [ ] 實作搜尋結果高亮顯示效果
  - [ ] 優化搜尋效能和記憶體使用
  - [ ] 實作鍵盤導航和無障礙功能
  - [ ] 加入進階搜尋功能（如果需要）
- [ ] 程式碼重構和最佳化
  - [ ] 重構重複程式碼和改善架構
  - [ ] 優化搜尋演算法和資料庫查詢
  - [ ] 加強錯誤處理和邊界情況
  - [ ] 確保程式碼符合專案編碼標準

### 階段 6: 完整驗證 (AC: 1-12)

- [ ] E2E BDD 測試執行
  - [ ] 運行完整的搜尋功能 E2E 測試
  - [ ] 驗證跨瀏覽器相容性
  - [ ] 測試效能和搜尋回應時間
- [ ] 回歸測試和品質確保
  - [ ] 確認不影響現有 Epic 2 和 3.1 功能
  - [ ] 運行完整測試套件
  - [ ] 驗證所有驗收標準達成

## Dev Notes

### 依賴前一個故事

此故事建立在 **Epic 2 完整實作** 和 **Story 3.1 檢視切換功能** 的基礎上：

- 需要 TodoTask 資料模型和 CRUD 基礎功能 (Story 2.1-2.4)
- 需要基本的 CQRS 架構和 TasksController
- 需要前端 TaskService 和 TaskListComponent
- 需要 Angular Signals 狀態管理機制
- 需要檢視切換功能（3.1）整合

### BDD 測試場景框架

此故事基於以下 BDD 測試場景實作：

**主要測試場景：**

```gherkin
Feature: 任務搜尋和篩選
  As a 生產力使用者
  I want to 搜尋和篩選我的任務
  So that 我可以快速找到特定的任務

Scenario: 即時搜尋任務
  Given 我有以下任務：
    | 任務描述          | 狀態  |
    | 開發搜尋功能      | 待辦  |
    | 測試搜尋功能      | 待辦  |
    | 撰寫搜尋文件      | 已完成 |
    | 開發其他功能      | 待辦  |
  When 我在搜尋框輸入 "搜尋"
  Then 我應該看到 3 個任務
  And 我應該看到任務 "開發搜尋功能"
  And 我應該看到任務 "測試搜尋功能"
  And 我應該看到任務 "撰寫搜尋文件"
  And 我不應該看到任務 "開發其他功能"
  And 匹配的文字應該被高亮顯示

Scenario: 搜尋不區分大小寫
  Given 我有任務 "開發新功能"
  When 我在搜尋框輸入 "開發"
  Then 我應該看到任務 "開發新功能"
  When 我在搜尋框輸入 "開發"
  Then 我應該看到任務 "開發新功能"

Scenario: 部分匹配搜尋
  Given 我有任務 "完成專案報告"
  When 我在搜尋框輸入 "專案"
  Then 我應該看到任務 "完成專案報告"
  When 我在搜尋框輸入 "報告"
  Then 我應該看到任務 "完成專案報告"

Scenario: 搜尋結合檢視切換
  Given 我有以下任務：
    | 任務描述          | 狀態  |
    | 開發功能 A        | 待辦  |
    | 開發功能 B        | 已完成 |
    | 測試功能 A        | 待辦  |
  And 我在「待辦」檢視
  When 我在搜尋框輸入 "開發"
  Then 我應該看到 1 個任務
  And 我應該看到任務 "開發功能 A"
  And 我不應該看到任務 "開發功能 B"

Scenario: 清空搜尋框恢復列表
  Given 我有 5 個任務
  And 我在搜尋框輸入 "特定"
  And 搜尋結果顯示 1 個任務
  When 我清空搜尋框
  Then 我應該看到 5 個任務

Scenario: 搜尋無結果
  Given 我有任務 "開發功能"
  When 我在搜尋框輸入 "不存在的任務"
  Then 我應該看到 "找不到匹配的任務" 提示
  And 我不應該看到任何任務

Scenario: 鍵盤快捷鍵
  Given 我在任務頁面
  When 我按下 Ctrl+F
  Then 搜尋框應該獲得焦點

Scenario: 搜尋效能和防抖動
  Given 我有 100 個任務
  When 我快速輸入 "test"
  Then 搜尋應該在 300ms 內完成
  And 不應該發送多個 API 請求
```

### 架構設計考量 [Source: architecture.md]

**後端 API 擴展：**

```csharp
public class GetTasksQuery : IRequest<List<TaskDto>>
{
    public TaskStatus? Status { get; set; } // 保持現有篩選功能
    public string? Search { get; set; } // 新增搜尋參數
}

public class GetTasksQueryHandler : IRequestHandler<GetTasksQuery, List<TaskDto>>
{
    public async Task<List<TaskDto>> Handle(GetTasksQuery request, CancellationToken cancellationToken)
    {
        var query = _context.Tasks.AsQueryable();

        // 狀態篩選（來自 3.1）
        if (request.Status.HasValue)
        {
            query = query.Where(t => t.IsCompleted == request.Status.Value);
        }

        // 搜尋功能（新增）
        if (!string.IsNullOrWhiteSpace(request.Search))
        {
            query = query.Where(t => EF.Functions.Like(t.Description.ToLower(), 
                $"%{request.Search.ToLower()}%"));
        }

        return await query
            .OrderBy(t => t.CreatedAt)
            .Select(t => t.ToDto())
            .ToListAsync(cancellationToken);
    }
}
```

**API 端點更新：**

- 現有端點：`GET /api/tasks?status=todo|completed|all`
- 擴展支援：`GET /api/tasks?status=todo&search=keyword`
- 回應格式保持一致，支援同時篩選和搜尋

**前端架構設計：**

```typescript
// 搜尋服務
@Injectable({ providedIn: "root" })
export class SearchService {
  private searchTerm = signal<string>('');
  private searchResults = signal<Task[]>([]);

  constructor(private taskService: TaskService) {}

  search(term: string): void {
    this.searchTerm.set(term);
    
    // 防抖動處理
    if (this.searchDebounce) {
      clearTimeout(this.searchDebounce);
    }
    
    this.searchDebounce = setTimeout(() => {
      this.performSearch(term);
    }, 300);
  }

  private async performSearch(term: string): Promise<void> {
    if (!term.trim()) {
      this.searchResults.set([]);
      return;
    }

    const results = await this.taskService.searchTasks(term);
    this.searchResults.set(results);
  }

  clearSearch(): void {
    this.searchTerm.set('');
    this.searchResults.set([]);
  }

  getSearchTerm(): string {
    return this.searchTerm();
  }

  getSearchResults(): Task[] {
    return this.searchResults();
  }
}

// TaskService 擴展
export class TaskService {
  async searchTasks(searchTerm: string, status?: TaskViewType): Promise<Task[]> {
    const params: any = {};
    
    if (searchTerm.trim()) {
      params.search = searchTerm;
    }
    
    if (status && status !== TaskViewType.ALL) {
      params.status = status === TaskViewType.TODO ? "todo" : "completed";
    }

    return this.http.get<Task[]>("/api/tasks", { params }).toPromise();
  }
}
```

### 前端元件設計 [Source: architecture.md]

**TaskSearchComponent 元件結構：**

```typescript
@Component({
  selector: "app-task-search",
  template: `
    <div class="search-container">
      <div class="search-input-wrapper">
        <i class="search-icon" aria-hidden="true">🔍</i>
        <input
          type="text"
          class="search-input"
          placeholder="搜尋任務..."
          [value]="searchTerm()"
          (input)="onSearchInput($event)"
          (keydown)="onKeyDown($event)"
          [attr.data-testid]="'search-input'"
          #searchInput
        />
        <button
          *ngIf="searchTerm()"
          class="clear-search"
          (click)="clearSearch()"
          [attr.data-testid]="'clear-search'"
          aria-label="清除搜尋"
        >
          ✕
        </button>
      </div>
    </div>
  `,
})
export class TaskSearchComponent {
  searchTerm = this.searchService.getSearchTerm;
  
  constructor(
    private searchService: SearchService,
    private keyboardService: KeyboardService
  ) {}

  ngOnInit() {
    // 註冊鍵盤快捷鍵 Ctrl+F
    this.keyboardService.registerShortcut('ctrl+f', () => {
      this.focusSearchInput();
    });
  }

  onSearchInput(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.searchService.search(input.value);
  }

  clearSearch(): void {
    this.searchService.clearSearch();
  }

  focusSearchInput(): void {
    const input = document.querySelector('[data-testid="search-input"]') as HTMLInputElement;
    if (input) {
      input.focus();
    }
  }

  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.clearSearch();
    }
  }
}
```

**任務高亮顯示元件：**

```typescript
@Component({
  selector: "app-task-highlight",
  template: `
    <span [innerHTML]="highlightedText()"></span>
  `,
})
export class TaskHighlightComponent {
  @Input() text: string = '';
  @Input() searchTerm: string = '';

  highlightedText = computed(() => {
    if (!this.searchTerm || !this.text) {
      return this.text;
    }

    const regex = new RegExp(`(${this.escapeRegex(this.searchTerm)})`, 'gi');
    return this.text.replace(regex, '<mark class="search-highlight">$1</mark>');
  });

  private escapeRegex(term: string): string {
    return term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}
```

### CSS 設計規範

**搜尋元件樣式：**

```scss
.search-container {
  margin-bottom: 16px;
  
  .search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    background: white;
    padding: 8px 12px;
    
    &:focus-within {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }

    .search-icon {
      color: #6b7280;
      margin-right: 8px;
    }

    .search-input {
      flex: 1;
      border: none;
      outline: none;
      font-size: 14px;
      
      &::placeholder {
        color: #9ca3af;
      }
    }

    .clear-search {
      background: none;
      border: none;
      color: #6b7280;
      cursor: pointer;
      padding: 4px;
      
      &:hover {
        color: #374151;
      }
    }
  }
}

.search-highlight {
  background-color: #fef08a;
  color: #713f12;
  font-weight: 500;
  padding: 1px 2px;
  border-radius: 2px;
}

.no-results {
  text-align: center;
  color: #6b7280;
  padding: 32px 16px;
  
  .no-results-icon {
    font-size: 48px;
    margin-bottom: 16px;
    opacity: 0.5;
  }
  
  .no-results-text {
    font-size: 16px;
    margin-bottom: 8px;
  }
  
  .no-results-suggestion {
    font-size: 14px;
    color: #9ca3af;
  }
}
```

### 測試要求 [Source: bdd-testing-strategy.md]

**前端 BDD 測試：**

- 測試檔案：`tests/frontend-bdd/features/task-searching.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/task-searching.steps.ts`
- 重點測試：即時搜尋、高亮顯示、防抖動、鍵盤快捷鍵

**後端 BDD 測試：**

- 測試檔案：`tests/backend-bdd/Features/TaskSearching.feature`
- 步驟定義：`tests/backend-bdd/StepDefinitions/TaskSearchingSteps.cs`
- 重點測試：搜尋API、查詢參數、效能、模糊匹配

**E2E BDD 測試：**

- 完整搜尋流程測試
- 搜尋與檢視切換整合測試
- 鍵盤快捷鍵和無障礙功能測試

### 效能考量

**前端效能：**

- 防抖動機制避免過度 API 呼叫
- 虛擬滾動處理大量搜尋結果
- 搜尋結果快取和記憶化
- 高亮顯示演算法最佳化

**後端效能：**

- 資料庫全文檢索索引（如果需要）
- 搜尋查詢最佳化和分頁
- API 回應時間監控（目標 < 300ms）

### Testing

**測試標準：** [Source: bdd-testing-strategy.md]

- 前端測試：Jasmine + Karma (Angular 預設)
- 後端測試：xUnit (.NET 標準測試框架)
- BDD 測試：SpecFlow (後端) + Cucumber (前端)
- E2E 測試：SpecFlow + Selenium WebDriver

**此故事的特定測試需求：**

- 搜尋輸入和即時回應測試
- API 搜尋參數和查詢測試
- 高亮顯示正確性測試
- 防抖動機制效能測試
- 鍵盤快捷鍵功能測試
- 無障礙功能相容性測試

## Change Log

| Date       | Version | Description                                   | Author       |
| ---------- | ------- | --------------------------------------------- | ------------ |
| 2025-08-21 | 1.0     | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_待 QA 代理填寫_