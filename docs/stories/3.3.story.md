# Story 3.3: 批量清除已完成任務功能

## Status

Draft

## Story

**As a** 生產力使用者，
**I want** 一次性清除所有已完成的任務，
**so that** 我可以保持任務列表的整潔並專注於未完成的工作。

## Acceptance Criteria

1. 在任務列表中顯示「清除已完成」按鈕
2. 只有當存在已完成任務時，按鈕才可點擊（否則禁用狀態）
3. 點擊按鈕時顯示確認對話框，詢問是否確定清除
4. 確認對話框顯示將被清除的任務數量
5. 用戶確認後，所有已完成任務立即從列表中移除
6. 清除操作後顯示成功提示訊息，包含清除的任務數量
7. 清除操作同時更新任務計數器
8. 支援鍵盤操作：Tab 導航和 Enter/Space 確認
9. 清除操作提供 Undo 功能，可在 5 秒內撤銷
10. 清除過程中顯示載入狀態，防止重複操作
11. 如果清除失敗，顯示錯誤訊息並保持原始狀態
12. 清除操作不影響待辦任務，只處理已完成任務

## Tasks / Subtasks

**⚡ 業務功能 Story - 必須遵循 BDD 驅動流程**

### 階段 1: BDD 場景建立 (Story 第一步)

- [ ] 撰寫完整 BDD 場景涵蓋所有清除功能情境 (AC: 1-12)
- [ ] 場景驗證：確保涵蓋主要使用情境、邊界條件和錯誤情況
- [ ] 場景品質檢查：具體、可測試、與功能需求一致

### 階段 2: 技術需求推導 (基於 BDD 場景)

- [ ] 從 BDD 場景推導後端技術需求 (AC: 5, 6, 10, 11)
  - [ ] 分析場景中的 API 需求：DELETE /api/tasks/completed
  - [ ] 設計 ClearCompletedTasksCommand 和相應的 Handler
  - [ ] 設計批量刪除邏輯和交易處理
  - [ ] 定義錯誤處理和回滾機制
- [ ] 從 BDD 場景推導前端技術需求 (AC: 1, 2, 3, 4, 7, 8, 9)
  - [ ] 分析場景中的 UI 元件：清除按鈕、確認對話框、Undo 通知
  - [ ] 設計 ClearCompletedComponent 元件基於場景互動
  - [ ] 設計確認對話框和 Undo 機制
  - [ ] 設計無障礙功能和鍵盤導航

### 階段 3: 測試先行 (TDD + BDD)

- [ ] 建立後端 BDD 測試 (Red Phase) (AC: 5, 6, 10, 11)
  - [ ] 建立 TaskClearCompleted.feature 文件
  - [ ] 實作 TaskClearCompletedSteps.cs 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有清除和錯誤場景
- [ ] 建立前端 BDD 測試 (Red Phase) (AC: 1, 2, 3, 4, 7, 8, 9)
  - [ ] 建立 task-clear-completed.feature 文件
  - [ ] 實作 task-clear-completed.steps.ts 步驟定義
  - [ ] 運行測試確認失敗 (Red)
  - [ ] 驗證測試覆蓋所有 UI 互動場景

### 階段 4: 最小實作 (Green Phase)

- [ ] 實作後端清除功能 (綠燈最小實作) (AC: 5, 6, 10, 11)
  - [ ] 建立 ClearCompletedTasksCommand 和相應的 Handler
  - [ ] 實作批量刪除邏輯和資料庫操作
  - [ ] 建立 TasksController DELETE 端點
  - [ ] 實作錯誤處理和交易回滾
  - [ ] 運行後端 BDD 測試確認通過 (Green)
- [ ] 實作前端清除功能 (綠燈最小實作) (AC: 1, 2, 3, 4, 7, 8)
  - [ ] 建立 ClearCompletedComponent 元件基礎結構
  - [ ] 實作清除按鈕和狀態管理
  - [ ] 建立確認對話框元件
  - [ ] 實作鍵盤導航和無障礙功能
  - [ ] 運行前端 BDD 測試確認通過 (Green)
- [ ] 整合前後端清除功能 (AC: 9, 12)
  - [ ] 擴展 TaskService 新增清除方法
  - [ ] 實作 Undo 功能和通知系統
  - [ ] 實作載入狀態和錯誤處理
  - [ ] 運行整合測試確認所有場景通過

### 階段 5: 重構和增強 (Blue Phase)

- [ ] 優化用戶體驗和效能 (AC: 9, 10)
  - [ ] 實作 Undo 功能的動畫效果
  - [ ] 優化批量刪除的效能
  - [ ] 實作進階確認選項（可選）
  - [ ] 加強錯誤處理和用戶回饋
- [ ] 程式碼重構和最佳化
  - [ ] 重構重複程式碼和改善架構
  - [ ] 優化資料庫操作和記憶體使用
  - [ ] 加強錯誤處理和邊界情況
  - [ ] 確保程式碼符合專案編碼標準

### 階段 6: 完整驗證 (AC: 1-12)

- [ ] E2E BDD 測試執行
  - [ ] 運行完整的清除功能 E2E 測試
  - [ ] 驗證跨瀏覽器相容性
  - [ ] 測試效能和大量資料處理
- [ ] 回歸測試和品質確保
  - [ ] 確認不影響現有 Epic 2 和 Story 3.1-3.2 功能
  - [ ] 運行完整測試套件
  - [ ] 驗證所有驗收標準達成

## Dev Notes

### 依賴前一個故事

此故事建立在 **Epic 2 完整實作** 和 **Story 3.1-3.2 功能** 的基礎上：

- 需要 TodoTask 資料模型和 CRUD 基礎功能 (Story 2.1-2.4)
- 需要基本的 CQRS 架構和 TasksController
- 需要前端 TaskService 和 TaskListComponent
- 需要 Angular Signals 狀態管理機制
- 需要檢視切換功能（3.1）用於即時更新列表
- 建議與搜尋功能（3.2）協調，確保清除後搜尋狀態正確

### BDD 測試場景框架

此故事基於以下 BDD 測試場景實作：

**主要測試場景：**

```gherkin
Feature: 批量清除已完成任務
  As a 生產力使用者
  I want to 批量清除已完成任務
  So that 我可以保持任務列表整潔

Scenario: 成功清除已完成任務
  Given 我有以下任務：
    | 任務描述        | 狀態  |
    | 開發功能        | 待辦  |
    | 測試功能        | 已完成 |
    | 撰寫文件        | 已完成 |
    | 部署系統        | 已完成 |
  When 我點擊「清除已完成」按鈕
  Then 我應該看到確認對話框
  And 對話框應該顯示「將清除 3 個已完成任務」
  When 我確認清除操作
  Then 我應該看到 1 個任務
  And 我應該看到任務 "開發功能"
  And 我不應該看到任務 "測試功能"
  And 我不應該看到任務 "撰寫文件"
  And 我不應該看到任務 "部署系統"
  And 我應該看到成功訊息 "已清除 3 個已完成任務"

Scenario: 按鈕狀態根據已完成任務存在性變化
  Given 我只有待辦任務
  Then 「清除已完成」按鈕應該被禁用
  When 我標記一個任務為已完成
  Then 「清除已完成」按鈕應該可點擊

Scenario: 取消清除操作
  Given 我有 2 個已完成任務
  When 我點擊「清除已完成」按鈕
  And 我在確認對話框中點擊「取消」
  Then 對話框應該關閉
  And 我應該仍然看到 2 個已完成任務
  And 任務列表應該保持不變

Scenario: Undo 功能
  Given 我有 3 個已完成任務
  When 我清除所有已完成任務
  Then 我應該看到 Undo 通知 "已清除 3 個任務"
  And Undo 通知應該包含「撤銷」按鈕
  When 我在 5 秒內點擊「撤銷」
  Then 所有已完成任務應該恢復
  And 我應該看到 3 個已完成任務

Scenario: Undo 通知自動消失
  Given 我清除了一些已完成任務
  And 我看到 Undo 通知
  When 我等待 5 秒
  Then Undo 通知應該自動消失
  And 撤銷選項應該不再可用

Scenario: 鍵盤導航支援
  Given 我有已完成任務
  When 我使用 Tab 鍵導航到「清除已完成」按鈕
  And 我按下 Enter 鍵
  Then 應該開啟確認對話框
  When 我使用 Tab 鍵在對話框中導航
  And 我按下 Space 鍵確認
  Then 應該執行清除操作

Scenario: 載入狀態防止重複操作
  Given 我有已完成任務
  When 我點擊「清除已完成」按鈕
  And 我確認清除操作
  Then 我應該看到載入指示器
  And 「清除已完成」按鈕應該被禁用
  When 清除操作完成
  Then 載入指示器應該消失
  And 按鈕狀態應該根據剩餘任務更新

Scenario: 清除操作失敗處理
  Given 我有已完成任務
  And 後端服務發生錯誤
  When 我嘗試清除已完成任務
  Then 我應該看到錯誤訊息 "清除失敗，請稍後再試"
  And 任務列表應該保持原始狀態
  And 「清除已完成」按鈕應該重新啟用

Scenario: 大量任務清除效能
  Given 我有 100 個已完成任務
  When 我清除所有已完成任務
  Then 清除操作應該在 2 秒內完成
  And 我應該看到成功訊息 "已清除 100 個已完成任務"
```

### 架構設計考量 [Source: architecture.md]

**後端 API 設計：**

```csharp
public class ClearCompletedTasksCommand : IRequest<ClearCompletedTasksResponse>
{
}

public class ClearCompletedTasksResponse
{
    public int DeletedCount { get; set; }
    public string Message { get; set; }
    public List<TaskDto> DeletedTasks { get; set; } // 用於 Undo 功能
}

public class ClearCompletedTasksCommandHandler : IRequestHandler<ClearCompletedTasksCommand, ClearCompletedTasksResponse>
{
    private readonly ITodoDbContext _context;

    public async Task<ClearCompletedTasksResponse> Handle(ClearCompletedTasksCommand request, CancellationToken cancellationToken)
    {
        using var transaction = await _context.Database.BeginTransactionAsync(cancellationToken);
        
        try
        {
            var completedTasks = await _context.Tasks
                .Where(t => t.IsCompleted)
                .ToListAsync(cancellationToken);

            if (!completedTasks.Any())
            {
                return new ClearCompletedTasksResponse
                {
                    DeletedCount = 0,
                    Message = "沒有已完成任務需要清除"
                };
            }

            var deletedTasksDto = completedTasks.Select(t => t.ToDto()).ToList();

            _context.Tasks.RemoveRange(completedTasks);
            await _context.SaveChangesAsync(cancellationToken);
            await transaction.CommitAsync(cancellationToken);

            return new ClearCompletedTasksResponse
            {
                DeletedCount = completedTasks.Count,
                Message = $"已清除 {completedTasks.Count} 個已完成任務",
                DeletedTasks = deletedTasksDto
            };
        }
        catch
        {
            await transaction.RollbackAsync(cancellationToken);
            throw;
        }
    }
}
```

**API 端點設計：**

```csharp
[ApiController]
[Route("api/[controller]")]
public class TasksController : ControllerBase
{
    [HttpDelete("completed")]
    public async Task<ActionResult<ClearCompletedTasksResponse>> ClearCompleted()
    {
        try
        {
            var result = await _mediator.Send(new ClearCompletedTasksCommand());
            return Ok(result);
        }
        catch (Exception ex)
        {
            return StatusCode(500, new { error = "清除操作失敗", message = ex.Message });
        }
    }
}
```

**前端架構設計：**

```typescript
// 清除服務
@Injectable({ providedIn: "root" })
export class ClearCompletedService {
  private undoTimer?: number;
  private deletedTasks = signal<Task[]>([]);
  private showUndo = signal<boolean>(false);

  constructor(
    private taskService: TaskService,
    private notificationService: NotificationService
  ) {}

  async clearCompleted(): Promise<void> {
    const result = await this.taskService.clearCompletedTasks();
    
    if (result.deletedCount > 0) {
      this.deletedTasks.set(result.deletedTasks);
      this.showUndoNotification(result.message, result.deletedCount);
    }
  }

  private showUndoNotification(message: string, count: number): void {
    this.showUndo.set(true);
    
    this.undoTimer = window.setTimeout(() => {
      this.showUndo.set(false);
      this.deletedTasks.set([]);
    }, 5000);
  }

  async undoClear(): Promise<void> {
    if (this.undoTimer) {
      clearTimeout(this.undoTimer);
    }

    const tasksToRestore = this.deletedTasks();
    await this.taskService.restoreTasks(tasksToRestore);
    
    this.showUndo.set(false);
    this.deletedTasks.set([]);
  }

  getUndoState() {
    return {
      showUndo: this.showUndo(),
      deletedCount: this.deletedTasks().length
    };
  }
}

// TaskService 擴展
export class TaskService {
  async clearCompletedTasks(): Promise<ClearCompletedTasksResponse> {
    return this.http.delete<ClearCompletedTasksResponse>('/api/tasks/completed').toPromise();
  }

  async restoreTasks(tasks: Task[]): Promise<void> {
    // 批量恢復任務的實作
    const promises = tasks.map(task => 
      this.http.post<Task>('/api/tasks', task).toPromise()
    );
    await Promise.all(promises);
  }
}
```

### 前端元件設計 [Source: architecture.md]

**ClearCompletedComponent 元件結構：**

```typescript
@Component({
  selector: "app-clear-completed",
  template: `
    <button
      class="clear-completed-btn"
      [disabled]="!hasCompletedTasks() || isLoading()"
      (click)="showConfirmDialog()"
      [attr.data-testid]="'clear-completed-button'"
    >
      <i class="icon" [class.loading]="isLoading()">🗑️</i>
      清除已完成
    </button>

    <app-confirm-dialog
      *ngIf="showDialog()"
      [title]="'確認清除'"
      [message]="getConfirmMessage()"
      [confirmText]="'清除'"
      [cancelText]="'取消'"
      (confirm)="confirmClear()"
      (cancel)="cancelClear()"
    />

    <app-undo-notification
      *ngIf="undoState().showUndo"
      [message]="getUndoMessage()"
      [countdown]="5"
      (undo)="undoClear()"
      (dismiss)="dismissUndo()"
    />
  `,
})
export class ClearCompletedComponent {
  private showDialog = signal<boolean>(false);
  private isLoading = signal<boolean>(false);
  
  completedTasksCount = computed(() => 
    this.taskService.getTasks().filter(t => t.isCompleted).length
  );
  
  hasCompletedTasks = computed(() => this.completedTasksCount() > 0);
  undoState = this.clearService.getUndoState;

  constructor(
    private clearService: ClearCompletedService,
    private taskService: TaskService
  ) {}

  showConfirmDialog(): void {
    this.showDialog.set(true);
  }

  cancelClear(): void {
    this.showDialog.set(false);
  }

  async confirmClear(): Promise<void> {
    this.showDialog.set(false);
    this.isLoading.set(true);

    try {
      await this.clearService.clearCompleted();
    } catch (error) {
      this.notificationService.showError('清除失敗，請稍後再試');
    } finally {
      this.isLoading.set(false);
    }
  }

  async undoClear(): Promise<void> {
    await this.clearService.undoClear();
  }

  dismissUndo(): void {
    // Undo 通知被手動關閉
  }

  getConfirmMessage(): string {
    const count = this.completedTasksCount();
    return `將清除 ${count} 個已完成任務，此操作可在 5 秒內撤銷`;
  }

  getUndoMessage(): string {
    const count = this.undoState().deletedCount;
    return `已清除 ${count} 個任務`;
  }
}
```

**確認對話框元件：**

```typescript
@Component({
  selector: "app-confirm-dialog",
  template: `
    <div class="dialog-overlay" (click)="cancel.emit()">
      <div class="dialog-content" (click)="$event.stopPropagation()">
        <h3 class="dialog-title">{{ title }}</h3>
        <p class="dialog-message">{{ message }}</p>
        <div class="dialog-actions">
          <button 
            class="btn btn-secondary"
            (click)="cancel.emit()"
            [attr.data-testid]="'cancel-button'"
          >
            {{ cancelText }}
          </button>
          <button 
            class="btn btn-danger"
            (click)="confirm.emit()"
            [attr.data-testid]="'confirm-button'"
          >
            {{ confirmText }}
          </button>
        </div>
      </div>
    </div>
  `,
})
export class ConfirmDialogComponent {
  @Input() title: string = '';
  @Input() message: string = '';
  @Input() confirmText: string = '確認';
  @Input() cancelText: string = '取消';
  
  @Output() confirm = new EventEmitter<void>();
  @Output() cancel = new EventEmitter<void>();

  @HostListener('keydown', ['$event'])
  onKeyDown(event: KeyboardEvent): void {
    if (event.key === 'Escape') {
      this.cancel.emit();
    } else if (event.key === 'Enter') {
      this.confirm.emit();
    }
  }
}
```

### CSS 設計規範

**清除功能樣式：**

```scss
.clear-completed-btn {
  padding: 8px 16px;
  border: 1px solid #dc2626;
  border-radius: 6px;
  background: white;
  color: #dc2626;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  gap: 8px;

  &:hover:not(:disabled) {
    background: #dc2626;
    color: white;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    background: #f5f5f5;
    color: #9ca3af;
    border-color: #e5e7eb;
  }

  .icon {
    &.loading {
      animation: spin 1s linear infinite;
    }
  }
}

.dialog-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;

  .dialog-content {
    background: white;
    border-radius: 8px;
    padding: 24px;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);

    .dialog-title {
      margin: 0 0 16px 0;
      font-size: 18px;
      font-weight: 600;
    }

    .dialog-message {
      margin: 0 0 24px 0;
      color: #6b7280;
      line-height: 1.5;
    }

    .dialog-actions {
      display: flex;
      justify-content: flex-end;
      gap: 12px;

      .btn {
        padding: 8px 16px;
        border: 1px solid;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;

        &.btn-secondary {
          background: white;
          color: #6b7280;
          border-color: #d1d5db;

          &:hover {
            background: #f9fafb;
          }
        }

        &.btn-danger {
          background: #dc2626;
          color: white;
          border-color: #dc2626;

          &:hover {
            background: #b91c1c;
          }
        }
      }
    }
  }
}

.undo-notification {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #374151;
  color: white;
  padding: 12px 20px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  gap: 16px;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
  animation: slideUp 0.3s ease;

  .undo-button {
    background: #3b82f6;
    color: white;
    border: none;
    padding: 6px 12px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 500;

    &:hover {
      background: #2563eb;
    }
  }

  .countdown {
    color: #9ca3af;
    font-size: 12px;
  }
}

@keyframes slideUp {
  from {
    transform: translateX(-50%) translateY(100%);
    opacity: 0;
  }
  to {
    transform: translateX(-50%) translateY(0);
    opacity: 1;
  }
}

@keyframes spin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}
```

### 測試要求 [Source: bdd-testing-strategy.md]

**前端 BDD 測試：**

- 測試檔案：`tests/frontend-bdd/features/task-clear-completed.feature`
- 步驟定義：`tests/frontend-bdd/step_definitions/task-clear-completed.steps.ts`
- 重點測試：清除按鈕狀態、確認對話框、Undo 功能、鍵盤導航

**後端 BDD 測試：**

- 測試檔案：`tests/backend-bdd/Features/TaskClearCompleted.feature`
- 步驟定義：`tests/backend-bdd/StepDefinitions/TaskClearCompletedSteps.cs`
- 重點測試：批量刪除API、交易處理、錯誤處理、效能

**E2E BDD 測試：**

- 完整清除流程測試
- Undo 功能整合測試
- 錯誤情況和恢復測試

### 效能考量

**前端效能：**

- Undo 功能的記憶體管理
- 大量任務清除的 UI 回應性
- 動畫效能最佳化

**後端效能：**

- 批量刪除的資料庫效能
- 交易處理的最佳化
- 大量資料的記憶體管理

### Testing

**測試標準：** [Source: bdd-testing-strategy.md]

- 前端測試：Jasmine + Karma (Angular 預設)
- 後端測試：xUnit (.NET 標準測試框架)
- BDD 測試：SpecFlow (後端) + Cucumber (前端)
- E2E 測試：SpecFlow + Selenium WebDriver

**此故事的特定測試需求：**

- 確認對話框互動測試
- 批量刪除 API 效能測試
- Undo 功能完整性測試
- 錯誤處理和恢復測試
- 鍵盤導航無障礙測試
- 大量資料處理壓力測試

## Change Log

| Date       | Version | Description                                   | Author       |
| ---------- | ------- | --------------------------------------------- | ------------ |
| 2025-08-21 | 1.0     | 初始故事建立，包含完整 BDD 場景框架和實作指導 | Scrum Master |

## Dev Agent Record

### Agent Model Used

_待開發代理填寫_

### Debug Log References

_待開發代理填寫_

### Completion Notes List

_待開發代理填寫_

### File List

_待開發代理填寫_

## QA Results

_待 QA 代理填寫_